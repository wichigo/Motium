<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChatHistoryState">
    <option name="toolDurations">
      <map>
        <entry key="toolu_bdrk_0111h2Wy41K5bz5vNLZALxPv" value="2" />
        <entry key="toolu_bdrk_011cXZiJxsjhazDcFrRC3U6f" value="1" />
        <entry key="toolu_bdrk_016FqxoDM18nhk7TegGJ457z" value="2" />
        <entry key="toolu_bdrk_018SLL441KXmxEvW9eEa8ahF" value="6" />
        <entry key="toolu_bdrk_019fUXsmiuYDSybfeday1KXe" value="4" />
        <entry key="toolu_bdrk_01AgWxjdcrkNBPUAQP3eRFJ1" value="77" />
        <entry key="toolu_bdrk_01BSajAtswvqFiys3gR5K4ZB" value="1" />
        <entry key="toolu_bdrk_01Dc2Vrm2zJBpU2GcCcNhRZ8" value="0" />
        <entry key="toolu_bdrk_01DhAAhSerQL1LLUjAi83hua" value="2" />
        <entry key="toolu_bdrk_01Estg7UGW9ayXbsnhyskCGM" value="6" />
        <entry key="toolu_bdrk_01GSkriTnC9xPRuFLpEaRaxK" value="0" />
        <entry key="toolu_bdrk_01KSX8PKEbRSewHznJddEdfv" value="63" />
        <entry key="toolu_bdrk_01R6hMZ4etoLsUmkz2Xzit6u" value="8" />
        <entry key="toolu_bdrk_01S4S2UJQYhwNBwf2rRmjpF1" value="14" />
        <entry key="toolu_bdrk_01UeTJj3qFfLim9ep1dRCrEv" value="1" />
      </map>
    </option>
    <option name="chatSessions" value="{&quot;7e492a82-c7f5-4ced-a4d6-a0bb921f1d5b&quot;:{&quot;id&quot;:&quot;7e492a82-c7f5-4ced-a4d6-a0bb921f1d5b&quot;,&quot;name&quot;:&quot;持久化登录机制重构（本地与 Supabase 同步）&quot;,&quot;timestamp&quot;:1761851100876,&quot;messages&quot;:[{&quot;role&quot;:&quot;user&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;\u003cuser_query\u003e\nrefactorise la persistence de connexion, je souhaite que l\u0027utilisateur reste connecté en permanence à l\u0027application, même à la fermeture/révouverture, la seule deconnexion possible est manuellement via le bouton de deconnexion, j\u0027utilise une bdd local dans l\u0027appli et une dans le cloud supabase pour la synchro\n\u003c/user_query\u003e&quot;}]},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Je vais examiner votre application pour comprendre la structure actuelle de la persistence de connexion et la refactoriser selon vos besoins. Commençons par explorer le projet.&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01KSX8PKEbRSewHznJddEdfv&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;list_dir&quot;,&quot;arguments&quot;:&quot;{\&quot;target_directory\&quot;: \&quot;.\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;list_dir&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01KSX8PKEbRSewHznJddEdfv&quot;,&quot;content&quot;:&quot;Contents of directory:\n\n[dir] app/ - oct. 29, 2025 08:03 PM\n[dir] app\\src/ - sept. 24, 2025 12:49 PM\n[dir] database/ - oct. 28, 2025 11:36 AM\n[dir] database\\migrations/ - oct. 28, 2025 11:36 AM\n[dir] gradle/ - oct. 12, 2025 10:11 PM\n[dir] gradle\\wrapper/ - sept. 24, 2025 12:49 PM\n[file] app\\build.gradle.kts (4,6KB, 150 lines) - oct. 12, 2025 10:11 PM\n[file] app\\proguard-rules.pro (750B, 21 lines) - sept. 24, 2025 12:49 PM\n[file] build.gradle.kts (218B, 5 lines) - sept. 24, 2025 12:49 PM\n[file] CUsersWylde_2y5smzdDownloadsmotium_logs.txt (2,3MB, 19039 lines) - oct. 08, 2025 06:18 PM\n[file] database\\supabase_schema.sql (11,6KB, 316 lines) - oct. 28, 2025 11:36 AM\n[file] database\\supabase_schema_simple.sql (9,0KB, 240 lines) - sept. 24, 2025 02:14 PM\n[file] gradle.properties (1,3KB, 23 lines) - sept. 24, 2025 12:49 PM\n[file] gradle\\libs.versions.toml (6,4KB, 160 lines) - oct. 12, 2025 10:11 PM\n[file] gradlew (5,6KB, 185 lines) - sept. 24, 2025 12:49 PM\n[file] gradlew.bat (2,7KB, 89 lines) - sept. 24, 2025 12:49 PM\n[file] hs_err_pid19276.log (180,9KB, 1743 lines) - oct. 20, 2025 09:40 PM\n[file] hs_err_pid19588.log (229,4KB, 2115 lines) - oct. 27, 2025 08:30 PM\n[file] hs_err_pid19952.log (231,2KB, 2142 lines) - oct. 27, 2025 07:38 PM\n[file] hs_err_pid23312.log (209,7KB, 1960 lines) - oct. 20, 2025 09:39 PM\n[file] hs_err_pid24424.log (260,4KB, 2342 lines) - oct. 27, 2025 07:48 PM\n[file] hs_err_pid25572.log (206,7KB, 1941 lines) - oct. 27, 2025 07:56 PM\n[file] hs_err_pid26852.log (235,1KB, 2186 lines) - oct. 27, 2025 08:31 PM\n[file] hs_err_pid29324.log (73,5KB, 914 lines) - oct. 08, 2025 07:58 AM\n[file] hs_err_pid34196.log (255,3KB, 2237 lines) - oct. 27, 2025 07:35 PM\n[file] hs_err_pid34540.log (224,6KB, 2085 lines) - oct. 26, 2025 03:39 PM\n[file] hs_err_pid34672.log (298,1KB, 2559 lines) - oct. 26, 2025 10:39 PM\n[file] hs_err_pid3640.log (207,9KB, 1966 lines) - oct. 20, 2025 09:36 PM\n[file] hs_err_pid37368.log (181,2KB, 1745 lines) - oct. 20, 2025 09:38 PM\n[file] hs_err_pid41280.log (151,4KB, 1534 lines) - oct. 27, 2025 08:01 PM\n[file] hs_err_pid44024.log (347,6KB, 2928 lines) - oct. 26, 2025 10:41 PM\n[file] hs_err_pid46608.log (236,6KB, 2092 lines) - oct. 26, 2025 10:40 PM\n[file] hs_err_pid46808.log (60,1KB, 776 lines) - oct. 27, 2025 07:29 PM\n[file] local.properties (457B, 10 lines) - sept. 24, 2025 12:49 PM\n[file] README_CURRENT_STATUS.md (2,3KB, 78 lines) - sept. 24, 2025 02:39 PM\n[file] README_SUPABASE_SETUP.md (3,8KB, 107 lines) - sept. 24, 2025 02:02 PM\n[file] replay_pid19952.log (0B, 0 lines) - oct. 27, 2025 07:38 PM\n[file] replay_pid34540.log (2,4MB, 23197 lines) - oct. 26, 2025 03:39 PM\n[file] replay_pid41280.log (1,8MB, 17471 lines) - oct. 27, 2025 08:01 PM\n[file] replay_pid44024.log (2,4MB, 22624 lines) - oct. 26, 2025 10:41 PM\n[file] replay_pid46808.log (0B, 0 lines) - oct. 27, 2025 07:29 PM\n[file] settings.gradle.kts (530B, 23 lines) - sept. 24, 2025 12:49 PM\n[file] simulate_gps_route.py (3,0KB, 89 lines) - sept. 24, 2025 10:29 PM\n[file] supabase_expenses_schema.sql (3,2KB, 90 lines) - oct. 26, 2025 05:35 PM\n[file] test_activity_recognition.py (5,4KB, 128 lines) - sept. 25, 2025 07:13 AM\n[file] test_trip_completion.py (3,0KB, 94 lines) - sept. 25, 2025 11:28 AM\n[other] nul - janv. 01, 1970 01:00 AM&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01Estg7UGW9ayXbsnhyskCGM&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;list_dir&quot;,&quot;arguments&quot;:&quot;{\&quot;target_directory\&quot;: \&quot;app/src\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;list_dir&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01Estg7UGW9ayXbsnhyskCGM&quot;,&quot;content&quot;:&quot;Contents of directory:\n\n[dir] app\\src\\androidTest/ - sept. 24, 2025 12:49 PM\n[dir] app\\src\\androidTest\\java/ - sept. 24, 2025 12:49 PM\n[dir] app\\src\\main/ - oct. 21, 2025 12:50 PM\n[dir] app\\src\\main\\java/ - sept. 24, 2025 12:49 PM\n[dir] app\\src\\main\\res/ - sept. 24, 2025 12:49 PM\n[dir] app\\src\\test/ - oct. 08, 2025 06:31 PM\n[dir] app\\src\\test\\java/ - sept. 24, 2025 12:49 PM\n[file] app\\src\\main\\AndroidManifest.xml (5,7KB, 137 lines) - oct. 21, 2025 12:50 PM\n[file] app\\src\\test\\README_TESTS.md (10,4KB, 368 lines) - oct. 08, 2025 06:31 PM&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_018SLL441KXmxEvW9eEa8ahF&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;list_dir&quot;,&quot;arguments&quot;:&quot;{\&quot;target_directory\&quot;: \&quot;app/src/main/java\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;list_dir&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_018SLL441KXmxEvW9eEa8ahF&quot;,&quot;content&quot;:&quot;Contents of directory:\n\n[dir] app\\src\\main\\java\\com/ - sept. 24, 2025 12:49 PM\n[dir] app\\src\\main\\java\\com\\application/ - sept. 24, 2025 12:49 PM&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_019fUXsmiuYDSybfeday1KXe&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;list_dir&quot;,&quot;arguments&quot;:&quot;{\&quot;target_directory\&quot;: \&quot;app/src/main/java/com/application\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;list_dir&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_019fUXsmiuYDSybfeday1KXe&quot;,&quot;content&quot;:&quot;Contents of directory:\n\n[dir] app\\src\\main\\java\\com\\application\\motium/ - oct. 12, 2025 09:55 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\data/ - oct. 29, 2025 07:26 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\domain/ - sept. 24, 2025 12:54 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation/ - oct. 21, 2025 01:25 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\service/ - oct. 28, 2025 10:02 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\utils/ - oct. 27, 2025 07:28 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\MotiumApplication.kt (2,2KB, 52 lines) - oct. 12, 2025 09:55 PM&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Maintenant, explorons la structure de l\u0027authentification et de la persistence :&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01R6hMZ4etoLsUmkz2Xzit6u&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;list_dir&quot;,&quot;arguments&quot;:&quot;{\&quot;target_directory\&quot;: \&quot;app/src/main/java/com/application/motium/data\&quot;}&quot;}},{&quot;id&quot;:&quot;toolu_bdrk_01S4S2UJQYhwNBwf2rRmjpF1&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;list_dir&quot;,&quot;arguments&quot;:&quot;{\&quot;target_directory\&quot;: \&quot;app/src/main/java/com/application/motium/presentation\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;list_dir&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01R6hMZ4etoLsUmkz2Xzit6u&quot;,&quot;content&quot;:&quot;Contents of directory:\n\n[dir] app\\src\\main\\java\\com\\application\\motium\\data\\geocoding/ - sept. 30, 2025 01:16 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\data\\preferences/ - oct. 12, 2025 10:21 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\data\\supabase/ - oct. 28, 2025 11:42 AM\n[dir] app\\src\\main\\java\\com\\application\\motium\\data\\sync/ - oct. 27, 2025 06:32 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\data\\geocoding\\NominatimService.kt (10,3KB, 286 lines) - sept. 30, 2025 01:16 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\data\\preferences\\SecureSessionStorage.kt (9,1KB, 260 lines) - oct. 12, 2025 06:33 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\data\\supabase\\SecureSessionManager.kt (6,6KB, 148 lines) - oct. 26, 2025 10:49 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\data\\supabase\\SupabaseAuthRepository.kt (39,4KB, 910 lines) - oct. 28, 2025 11:42 AM\n[file] app\\src\\main\\java\\com\\application\\motium\\data\\supabase\\SupabaseClient.kt (3,2KB, 75 lines) - oct. 26, 2025 05:52 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\data\\supabase\\SupabaseExpenseRepository.kt (8,3KB, 234 lines) - oct. 26, 2025 10:12 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\data\\supabase\\SupabaseTripRepository.kt (19,4KB, 465 lines) - oct. 27, 2025 06:32 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\data\\supabase\\SupabaseVehicleRepository.kt (14,5KB, 388 lines) - oct. 20, 2025 03:12 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\data\\sync\\PendingSyncQueue.kt (6,3KB, 198 lines) - oct. 08, 2025 01:04 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\data\\sync\\SessionRefreshWorker.kt (3,9KB, 81 lines) - oct. 21, 2025 06:27 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\data\\sync\\SupabaseSyncManager.kt (11,9KB, 328 lines) - oct. 27, 2025 06:32 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\data\\sync\\SyncScheduler.kt (4,8KB, 116 lines) - oct. 12, 2025 09:53 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\data\\TripRepository.kt (18,2KB, 420 lines) - oct. 29, 2025 07:26 PM&quot;},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;list_dir&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01S4S2UJQYhwNBwf2rRmjpF1&quot;,&quot;content&quot;:&quot;Contents of directory:\n\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\auth/ - oct. 29, 2025 08:03 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\components/ - oct. 28, 2025 11:58 AM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\debug/ - sept. 24, 2025 10:14 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\enterprise/ - oct. 28, 2025 11:54 AM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\enterprise\\employees/ - oct. 28, 2025 12:08 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\enterprise\\export/ - oct. 28, 2025 11:57 AM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\enterprise\\facturation/ - oct. 28, 2025 11:57 AM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\enterprise\\home/ - oct. 28, 2025 11:57 AM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\enterprise\\schedule/ - oct. 28, 2025 11:56 AM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\individual/ - oct. 26, 2025 10:24 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\individual\\addtrip/ - oct. 26, 2025 10:12 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\individual\\calendar/ - oct. 28, 2025 11:18 AM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\individual\\edittrip/ - oct. 29, 2025 07:30 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\individual\\export/ - oct. 28, 2025 11:23 AM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\individual\\home/ - oct. 26, 2025 05:44 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\individual\\settings/ - oct. 28, 2025 11:32 AM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\individual\\tripdetails/ - oct. 29, 2025 07:07 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\individual\\vehicles/ - oct. 21, 2025 01:09 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\navigation/ - oct. 28, 2025 12:06 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\splash/ - oct. 01, 2025 01:26 PM\n[dir] app\\src\\main\\java\\com\\application\\motium\\presentation\\theme/ - sept. 29, 2025 10:58 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\auth\\AuthViewModel.kt (7,3KB, 192 lines) - oct. 29, 2025 08:03 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\auth\\LoginScreen.kt (15,9KB, 393 lines) - oct. 29, 2025 07:47 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\auth\\RegisterScreen.kt (17,0KB, 449 lines) - oct. 29, 2025 07:47 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\components\\AddressAutocomplete.kt (5,9KB, 170 lines) - sept. 28, 2025 02:56 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\components\\BottomNavigation.kt (4,3KB, 112 lines) - oct. 16, 2025 07:57 AM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\components\\EnterpriseBottomNavigation.kt (9,4KB, 235 lines) - oct. 28, 2025 11:58 AM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\components\\MapView.kt (5,9KB, 161 lines) - sept. 24, 2025 08:37 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\components\\MiniMap.kt (16,5KB, 318 lines) - oct. 27, 2025 07:04 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\components\\PremiumDialog.kt (9,8KB, 274 lines) - oct. 16, 2025 07:57 AM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\debug\\LogViewerScreen.kt (6,3KB, 160 lines) - sept. 24, 2025 10:14 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\MainActivity.kt (7,2KB, 177 lines) - oct. 21, 2025 01:25 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\navigation\\MotiumNavHost.kt (17,6KB, 378 lines) - oct. 28, 2025 12:06 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\splash\\SplashScreen.kt (2,0KB, 62 lines) - oct. 01, 2025 01:26 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\theme\\Color.kt (1,2KB, 40 lines) - sept. 29, 2025 10:57 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\theme\\Theme.kt (2,9KB, 85 lines) - sept. 29, 2025 10:58 PM\n[file] app\\src\\main\\java\\com\\application\\motium\\presentation\\theme\\Type.kt (948B, 32 lines) - sept. 24, 2025 08:37 PM&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Maintenant, examinons les fichiers clés liés à l\u0027authentification et à la persistence :&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_0111h2Wy41K5bz5vNLZALxPv&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;app/src/main/java/com/application/motium/data/preferences/SecureSessionStorage.kt\&quot;}&quot;}},{&quot;id&quot;:&quot;toolu_bdrk_011cXZiJxsjhazDcFrRC3U6f&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;app/src/main/java/com/application/motium/data/supabase/SecureSessionManager.kt\&quot;}&quot;}},{&quot;id&quot;:&quot;toolu_bdrk_01Dc2Vrm2zJBpU2GcCcNhRZ8&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;app/src/main/java/com/application/motium/data/supabase/SupabaseAuthRepository.kt\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_0111h2Wy41K5bz5vNLZALxPv&quot;,&quot;content&quot;:&quot;package com.application.motium.data.preferences\n\nimport android.content.Context\nimport android.content.SharedPreferences\nimport androidx.security.crypto.EncryptedSharedPreferences\nimport androidx.security.crypto.MasterKey\nimport com.application.motium.MotiumApplication\n\n/**\n * Stockage sécurisé des sessions Supabase avec EncryptedSharedPreferences\n * Implémente le chiffrement AES256 pour protéger les tokens d\u0027authentification\n */\nclass SecureSessionStorage(context: Context) {\n\n    private val masterKey \u003d MasterKey.Builder(context)\n        .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)\n        .build()\n\n    private val encryptedPrefs: SharedPreferences \u003d try {\n        EncryptedSharedPreferences.create(\n            context,\n            \&quot;supabase_secure_session\&quot;,\n            masterKey,\n            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,\n            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM\n        )\n    } catch (e: Exception) {\n        MotiumApplication.logger.e(\&quot;❌ Erreur création EncryptedSharedPreferences, fallback vers SharedPreferences standard\&quot;, \&quot;SecureSession\&quot;, e)\n        // Fallback vers SharedPreferences standard si EncryptedSharedPreferences échoue\n        context.getSharedPreferences(\&quot;supabase_session_fallback\&quot;, Context.MODE_PRIVATE)\n    }\n\n    companion object {\n        private const val KEY_ACCESS_TOKEN \u003d \&quot;access_token\&quot;\n        private const val KEY_REFRESH_TOKEN \u003d \&quot;refresh_token\&quot;\n        private const val KEY_EXPIRES_AT \u003d \&quot;expires_at\&quot;\n        private const val KEY_USER_ID \u003d \&quot;user_id\&quot;\n        private const val KEY_USER_EMAIL \u003d \&quot;user_email\&quot;\n        private const val KEY_LAST_REFRESH_TIME \u003d \&quot;last_refresh_time\&quot;\n        private const val KEY_TOKEN_TYPE \u003d \&quot;token_type\&quot;\n    }\n\n    /**\n     * Données de session Supabase\n     */\n    data class SessionData(\n        val accessToken: String,\n        val refreshToken: String,\n        val expiresAt: Long, // Timestamp Unix en millisecondes\n        val userId: String,\n        val userEmail: String,\n        val tokenType: String \u003d \&quot;Bearer\&quot;,\n        val lastRefreshTime: Long \u003d System.currentTimeMillis()\n    )\n\n    /**\n     * Sauvegarde la session de manière sécurisée\n     */\n    fun saveSession(session: SessionData) {\n        try {\n            encryptedPrefs.edit()\n                .putString(KEY_ACCESS_TOKEN, session.accessToken)\n                .putString(KEY_REFRESH_TOKEN, session.refreshToken)\n                .putLong(KEY_EXPIRES_AT, session.expiresAt)\n                .putString(KEY_USER_ID, session.userId)\n                .putString(KEY_USER_EMAIL, session.userEmail)\n                .putString(KEY_TOKEN_TYPE, session.tokenType)\n                .putLong(KEY_LAST_REFRESH_TIME, session.lastRefreshTime)\n                .apply()\n\n            MotiumApplication.logger.i(\n                \&quot;✅ Session sauvegardée de manière sécurisée (expire dans ${(session.expiresAt - System.currentTimeMillis()) / 1000 / 60} min)\&quot;,\n                \&quot;SecureSession\&quot;\n            )\n        } catch (e: Exception) {\n            MotiumApplication.logger.e(\&quot;❌ Erreur sauvegarde session sécurisée: ${e.message}\&quot;, \&quot;SecureSession\&quot;, e)\n        }\n    }\n\n    /**\n     * Récupère la session sauvegardée\n     */\n    fun restoreSession(): SessionData? {\n        return try {\n            val accessToken \u003d encryptedPrefs.getString(KEY_ACCESS_TOKEN, null)\n            val refreshToken \u003d encryptedPrefs.getString(KEY_REFRESH_TOKEN, null)\n            val expiresAt \u003d encryptedPrefs.getLong(KEY_EXPIRES_AT, 0)\n            val userId \u003d encryptedPrefs.getString(KEY_USER_ID, null)\n            val userEmail \u003d encryptedPrefs.getString(KEY_USER_EMAIL, null)\n            val tokenType \u003d encryptedPrefs.getString(KEY_TOKEN_TYPE, \&quot;Bearer\&quot;) ?: \&quot;Bearer\&quot;\n            val lastRefreshTime \u003d encryptedPrefs.getLong(KEY_LAST_REFRESH_TIME, 0)\n\n            if (accessToken !\u003d null \u0026\u0026 refreshToken !\u003d null \u0026\u0026 userId !\u003d null \u0026\u0026 userEmail !\u003d null) {\n                MotiumApplication.logger.i(\n                    \&quot;✅ Session restaurée (expire dans ${(expiresAt - System.currentTimeMillis()) / 1000 / 60} min)\&quot;,\n                    \&quot;SecureSession\&quot;\n                )\n                SessionData(\n                    accessToken \u003d accessToken,\n                    refreshToken \u003d refreshToken,\n                    expiresAt \u003d expiresAt,\n                    userId \u003d userId,\n                    userEmail \u003d userEmail,\n                    tokenType \u003d tokenType,\n                    lastRefreshTime \u003d lastRefreshTime\n                )\n            } else {\n                MotiumApplication.logger.w(\&quot;⚠️ Session incomplète trouvée, certaines données manquent\&quot;, \&quot;SecureSession\&quot;)\n                null\n            }\n        } catch (e: Exception) {\n            MotiumApplication.logger.e(\&quot;❌ Erreur restauration session: ${e.message}\&quot;, \&quot;SecureSession\&quot;, e)\n            null\n        }\n    }\n\n    /**\n     * Vérifie si le token va expirer bientôt\n     * @param thresholdMinutes Minutes avant expiration pour considérer comme \&quot;expire bientôt\&quot;\n     * @return true si le token expire dans moins de thresholdMinutes minutes\n     */\n    fun isTokenExpiringSoon(thresholdMinutes: Int \u003d 5): Boolean {\n        val expiresAt \u003d encryptedPrefs.getLong(KEY_EXPIRES_AT, 0)\n        if (expiresAt \u003d\u003d 0L) return true\n\n        val now \u003d System.currentTimeMillis()\n        val timeUntilExpiry \u003d expiresAt - now\n        val thresholdMillis \u003d thresholdMinutes * 60 * 1000L\n\n        val expiringSoon \u003d timeUntilExpiry \u003c thresholdMillis\n\n        if (expiringSoon) {\n            MotiumApplication.logger.w(\n                \&quot;⚠️ Token expire bientôt (dans ${timeUntilExpiry / 1000 / 60} min)\&quot;,\n                \&quot;SecureSession\&quot;\n            )\n        }\n\n        return expiringSoon\n    }\n\n    /**\n     * Vérifie si le token est déjà expiré\n     */\n    fun isTokenExpired(): Boolean {\n        val expiresAt \u003d encryptedPrefs.getLong(KEY_EXPIRES_AT, 0)\n        if (expiresAt \u003d\u003d 0L) return true\n\n        val isExpired \u003d System.currentTimeMillis() \u003e\u003d expiresAt\n\n        if (isExpired) {\n            MotiumApplication.logger.e(\&quot;❌ Token expiré\&quot;, \&quot;SecureSession\&quot;)\n        }\n\n        return isExpired\n    }\n\n    /**\n     * Met à jour uniquement le timestamp de dernier refresh\n     */\n    fun updateLastRefreshTime() {\n        encryptedPrefs.edit()\n            .putLong(KEY_LAST_REFRESH_TIME, System.currentTimeMillis())\n            .apply()\n    }\n\n    /**\n     * Récupère le temps écoulé depuis le dernier refresh en minutes\n     */\n    fun getMinutesSinceLastRefresh(): Long {\n        val lastRefresh \u003d encryptedPrefs.getLong(KEY_LAST_REFRESH_TIME, 0)\n        if (lastRefresh \u003d\u003d 0L) return Long.MAX_VALUE\n\n        return (System.currentTimeMillis() - lastRefresh) / 1000 / 60\n    }\n\n    /**\n     * Vérifie si une session existe (même expirée)\n     */\n    fun hasSession(): Boolean {\n        val accessToken \u003d encryptedPrefs.getString(KEY_ACCESS_TOKEN, null)\n        val refreshToken \u003d encryptedPrefs.getString(KEY_REFRESH_TOKEN, null)\n        return accessToken !\u003d null \u0026\u0026 refreshToken !\u003d null\n    }\n\n    /**\n     * Vérifie si la session est valide (existe et non expirée)\n     */\n    fun hasValidSession(): Boolean {\n        return hasSession() \u0026\u0026 !isTokenExpired()\n    }\n\n    /**\n     * Efface toutes les données de session\n     */\n    fun clearSession() {\n        try {\n            encryptedPrefs.edit().clear().apply()\n            MotiumApplication.logger.i(\&quot;️ Session sécurisée effacée\&quot;, \&quot;SecureSession\&quot;)\n        } catch (e: Exception) {\n            MotiumApplication.logger.e(\&quot;❌ Erreur effacement session: ${e.message}\&quot;, \&quot;SecureSession\&quot;, e)\n        }\n    }\n\n    /**\n     * Récupère le refresh token\n     */\n    fun getRefreshToken(): String? {\n        return encryptedPrefs.getString(KEY_REFRESH_TOKEN, null)\n    }\n\n    /**\n     * Récupère l\u0027access token\n     */\n    fun getAccessToken(): String? {\n        return encryptedPrefs.getString(KEY_ACCESS_TOKEN, null)\n    }\n\n    /**\n     * Récupère l\u0027ID utilisateur\n     */\n    fun getUserId(): String? {\n        return encryptedPrefs.getString(KEY_USER_ID, null)\n    }\n\n    /**\n     * Récupère l\u0027email utilisateur\n     */\n    fun getUserEmail(): String? {\n        return encryptedPrefs.getString(KEY_USER_EMAIL, null)\n    }\n\n    /**\n     * Log des informations de debug sur la session\n     */\n    fun debugLogSession() {\n        val hasSession \u003d hasSession()\n        val expiresAt \u003d encryptedPrefs.getLong(KEY_EXPIRES_AT, 0)\n        val lastRefresh \u003d encryptedPrefs.getLong(KEY_LAST_REFRESH_TIME, 0)\n        val userId \u003d getUserId()\n        val userEmail \u003d getUserEmail()\n\n        val now \u003d System.currentTimeMillis()\n        val minutesUntilExpiry \u003d if (expiresAt \u003e 0) (expiresAt - now) / 1000 / 60 else -1\n        val minutesSinceRefresh \u003d if (lastRefresh \u003e 0) (now - lastRefresh) / 1000 / 60 else -1\n\n        MotiumApplication.logger.d(\n            \&quot;\&quot;\&quot;\n             Session Debug Info:\n              - Has session: $hasSession\n              - User: $userEmail ($userId)\n              - Expires in: $minutesUntilExpiry minutes\n              - Last refresh: $minutesSinceRefresh minutes ago\n              - Is expired: ${isTokenExpired()}\n              - Expires soon: ${isTokenExpiringSoon()}\n            \&quot;\&quot;\&quot;.trimIndent(),\n            \&quot;SecureSession\&quot;\n        )\n    }\n}\n&quot;},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_011cXZiJxsjhazDcFrRC3U6f&quot;,&quot;content&quot;:&quot;package com.application.motium.data.supabase\n\nimport android.content.Context\nimport com.application.motium.MotiumApplication\nimport com.application.motium.data.preferences.SecureSessionStorage\nimport io.github.jan.supabase.auth.user.UserSession\nimport io.github.jan.supabase.auth.SessionManager\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n/**\n * SessionManager personnalise pour Supabase qui utilise SecureSessionStorage (chiffre)\n * au lieu de SharedPreferences (non chiffre).\n *\n * Cela permet au SDK Supabase de persister automatiquement les sessions\n * de maniere securisee sans conflit avec notre systeme de gestion de session.\n */\nclass SecureSessionManager(context: Context) : SessionManager {\n\n    private val secureStorage \u003d SecureSessionStorage(context.applicationContext)\n\n    override suspend fun deleteSession() {\n        withContext(Dispatchers.IO) {\n            try {\n                MotiumApplication.logger.d(\&quot;SecureSessionManager: Deleting session\&quot;, \&quot;SecureSessionManager\&quot;)\n                secureStorage.clearSession()\n            } catch (e: Exception) {\n                MotiumApplication.logger.e(\&quot;Error deleting session: ${e.message}\&quot;, \&quot;SecureSessionManager\&quot;, e)\n            }\n        }\n    }\n\n    override suspend fun loadSession(): UserSession? {\n        return withContext(Dispatchers.IO) {\n            try {\n                val savedSession \u003d secureStorage.restoreSession()\n\n                if (savedSession !\u003d null) {\n                    // Calculer le temps d\u0027expiration restant\n                    val expiresInMs \u003d savedSession.expiresAt - System.currentTimeMillis()\n                    val expiresInSeconds \u003d (expiresInMs / 1000).toLong()\n\n                    // Si le token est expire, ne pas le retourner\n                    if (expiresInSeconds \u003c\u003d 0) {\n                        MotiumApplication.logger.w(\&quot;SecureSessionManager: Token expired, returning null\&quot;, \&quot;SecureSessionManager\&quot;)\n                        return@withContext null\n                    }\n\n                    MotiumApplication.logger.d(\n                        \&quot;SecureSessionManager: Loaded session (expires in ${expiresInSeconds}s)\&quot;,\n                        \&quot;SecureSessionManager\&quot;\n                    )\n\n                    // Convertir notre SavedSession en UserSession du SDK\n                    UserSession(\n                        accessToken \u003d savedSession.accessToken,\n                        refreshToken \u003d savedSession.refreshToken,\n                        expiresIn \u003d expiresInSeconds,\n                        tokenType \u003d savedSession.tokenType,\n                        user \u003d null\n                    )\n                } else {\n                    MotiumApplication.logger.d(\&quot;SecureSessionManager: No session found\&quot;, \&quot;SecureSessionManager\&quot;)\n                    null\n                }\n            } catch (e: Exception) {\n                MotiumApplication.logger.e(\&quot;Error loading session: ${e.message}\&quot;, \&quot;SecureSessionManager\&quot;, e)\n                null\n            }\n        }\n    }\n\n    override suspend fun saveSession(session: UserSession) {\n        withContext(Dispatchers.IO) {\n            try {\n                // Calculer le timestamp d\u0027expiration\n                val expiresAtMs \u003d System.currentTimeMillis() + (session.expiresIn * 1000)\n\n                MotiumApplication.logger.d(\n                    \&quot;SecureSessionManager: Saving session (expires in ${session.expiresIn}s)\&quot;,\n                    \&quot;SecureSessionManager\&quot;\n                )\n\n                // IMPORTANT: Obtenir userId et userEmail de differentes sources\n                // Priorite: session.user \u003e storage existant \u003e extraction du JWT\n                var userId \u003d session.user?.id\n                var userEmail \u003d session.user?.email\n\n                // Si user est null, essayer de recuperer depuis le storage\n                if (userId.isNullOrBlank()) {\n                    userId \u003d secureStorage.getUserId()\n                }\n                if (userEmail.isNullOrBlank()) {\n                    userEmail \u003d secureStorage.getUserEmail()\n                }\n\n                // Si toujours vide, extraire du JWT access token\n                if (userId.isNullOrBlank() || userEmail.isNullOrBlank()) {\n                    try {\n                        // Decoder le JWT pour extraire sub (userId) et email\n                        val parts \u003d session.accessToken.split(\&quot;.\&quot;)\n                        if (parts.size \u003d\u003d 3) {\n                            val payload \u003d String(android.util.Base64.decode(parts[1], android.util.Base64.URL_SAFE or android.util.Base64.NO_WRAP))\n                            // Parse JSON basique pour extraire sub et email\n                            val subMatch \u003d Regex(\&quot;\\\&quot;sub\\\&quot;:\\\&quot;([^\\\&quot;]+)\\\&quot;\&quot;).find(payload)\n                            val emailMatch \u003d Regex(\&quot;\\\&quot;email\\\&quot;:\\\&quot;([^\\\&quot;]+)\\\&quot;\&quot;).find(payload)\n\n                            if (userId.isNullOrBlank() \u0026\u0026 subMatch !\u003d null) {\n                                userId \u003d subMatch.groupValues[1]\n                                MotiumApplication.logger.d(\&quot;Extracted userId from JWT: $userId\&quot;, \&quot;SecureSessionManager\&quot;)\n                            }\n                            if (userEmail.isNullOrBlank() \u0026\u0026 emailMatch !\u003d null) {\n                                userEmail \u003d emailMatch.groupValues[1]\n                                MotiumApplication.logger.d(\&quot;Extracted email from JWT: $userEmail\&quot;, \&quot;SecureSessionManager\&quot;)\n                            }\n                        }\n                    } catch (e: Exception) {\n                        MotiumApplication.logger.w(\&quot;Failed to extract user info from JWT: ${e.message}\&quot;, \&quot;SecureSessionManager\&quot;)\n                    }\n                }\n\n                // Valeurs finales (ne jamais stocker vide)\n                val finalUserId \u003d userId ?: \&quot;\&quot;\n                val finalUserEmail \u003d userEmail ?: \&quot;\&quot;\n\n                // Creer un SessionData\n                val sessionData \u003d SecureSessionStorage.SessionData(\n                    accessToken \u003d session.accessToken,\n                    refreshToken \u003d session.refreshToken,\n                    expiresAt \u003d expiresAtMs,\n                    tokenType \u003d session.tokenType,\n                    userEmail \u003d finalUserEmail,\n                    userId \u003d finalUserId\n                )\n\n                // Sauvegarder avec SecureSessionStorage\n                secureStorage.saveSession(sessionData)\n\n                MotiumApplication.logger.i(\n                    \&quot;SecureSessionManager: Session saved successfully (user: $finalUserId, email: $finalUserEmail)\&quot;,\n                    \&quot;SecureSessionManager\&quot;\n                )\n            } catch (e: Exception) {\n                MotiumApplication.logger.e(\&quot;Error saving session: ${e.message}\&quot;, \&quot;SecureSessionManager\&quot;, e)\n            }\n        }\n    }\n}\n&quot;},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01Dc2Vrm2zJBpU2GcCcNhRZ8&quot;,&quot;content&quot;:&quot;package com.application.motium.data.supabase\n\nimport android.content.Context\nimport com.application.motium.BuildConfig\nimport com.application.motium.MotiumApplication\nimport com.application.motium.data.preferences.SecureSessionStorage\nimport com.application.motium.data.sync.SyncScheduler\nimport com.application.motium.domain.model.*\nimport com.application.motium.domain.repository.AuthRepository\nimport io.github.jan.supabase.auth.Auth\nimport io.github.jan.supabase.auth.auth\nimport io.github.jan.supabase.auth.providers.builtin.Email\nimport io.github.jan.supabase.auth.providers.Google\nimport io.github.jan.supabase.postgrest.from\nimport io.github.jan.supabase.postgrest.postgrest\nimport kotlinx.coroutines.flow.Flow\nimport kotlinx.coroutines.flow.MutableStateFlow\nimport kotlinx.coroutines.flow.asStateFlow\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.SupervisorJob\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.delay\nimport kotlinx.coroutines.sync.Mutex\nimport kotlinx.coroutines.sync.withLock\nimport kotlinx.datetime.Clock\nimport kotlinx.datetime.Instant\nimport kotlinx.serialization.Serializable\nimport kotlinx.serialization.json.buildJsonObject\nimport kotlinx.serialization.json.put\n\n@OptIn(kotlin.time.ExperimentalTime::class)\nclass SupabaseAuthRepository(private val context: Context) : AuthRepository {\n\n    private val client \u003d SupabaseClient.client\n    private val auth: Auth \u003d client.auth\n    private val postgres \u003d client.postgrest\n    private val secureSessionStorage \u003d SecureSessionStorage(context)\n\n    // Identifiants de développement pour la connexion automatique\n    companion object {\n        private const val DEV_EMAIL \u003d \&quot;wyldelphegreg@gmail.com\&quot;\n        private const val DEV_PASSWORD \u003d \&quot;password123\&quot; // TEMPORAIREMENT DÉSACTIVÉ - À CORRIGER\n        private const val DEV_USER_ID \u003d \&quot;134da308-52aa-48a3-b619-c3e2500610ec\&quot;\n        private const val AUTO_LOGIN_ENABLED \u003d false // DÉSACTIVÉ car identifiants invalides\n\n        fun isDevelopmentMode(): Boolean {\n            return BuildConfig.DEBUG\n        }\n\n        // Singleton pattern\n        @Volatile\n        private var instance: SupabaseAuthRepository? \u003d null\n\n        fun getInstance(context: Context): SupabaseAuthRepository {\n            return instance ?: synchronized(this) {\n                instance ?: SupabaseAuthRepository(context.applicationContext).also {\n                    instance \u003d it\n                }\n            }\n        }\n    }\n\n    private val _authState \u003d MutableStateFlow(\n        AuthState(\n            isLoading \u003d true, // Démarrer en mode chargement\n            isAuthenticated \u003d false,\n            authUser \u003d null,\n            user \u003d null,\n            error \u003d null\n        )\n    )\n    override val authState: Flow\u003cAuthState\u003e \u003d _authState.asStateFlow()\n\n    // CoroutineScope pour le rafraîchissement de session (DOIT être avant le bloc init)\n    private val sessionRefreshScope \u003d CoroutineScope(Dispatchers.IO + SupervisorJob())\n\n    // Mutex pour éviter les validations concurrentes de session (race condition fix)\n    private val sessionValidationMutex \u003d Mutex()\n\n    @Serializable\n    data class UserProfile(\n        val id: String,\n        val name: String,\n        val email: String,\n        val role: String,\n        val organization_id: String? \u003d null,\n        val organization_name: String? \u003d null,\n        val subscription_type: String \u003d \&quot;FREE\&quot;,\n        val subscription_expires_at: String? \u003d null,\n        val monthly_trip_count: Int \u003d 0,\n        val created_at: String,\n        val updated_at: String\n    )\n\n    init {\n        // Initialize auth state asynchronously and set up session persistence\n        // ⚠️ NE JAMAIS utiliser runBlocking ici - cela bloque le thread principal et cause des ANR!\n        // L\u0027initialisation se fait en arrière-plan de manière non-bloquante\n        sessionRefreshScope.launch {\n            // Vérifier si une session existe déjà\n            initializeAuthSession()\n        }\n\n        // Configurer un rafraîchissement automatique de la session toutes les 45 minutes\n        // (les tokens Supabase expirent généralement après 1 heure)\n        startSessionRefreshTimer()\n    }\n\n    /**\n     * Démarre un timer qui rafraîchit la session toutes les 15 minutes\n     * pour éviter l\u0027expiration du token (qui expire généralement après 1 heure)\n     * Note: Double couche de sécurité avec SupabaseConnectionService (20min)\n     */\n    private fun startSessionRefreshTimer() {\n        sessionRefreshScope.launch {\n            while (true) {\n                // Attendre 15 minutes (agressif pour garantir session valide)\n                delay(15 * 60 * 1000L)\n\n                try {\n                    // Vérifier si l\u0027utilisateur est toujours connecté\n                    if (auth.currentUserOrNull() !\u003d null) {\n                        MotiumApplication.logger.i(\&quot; Rafraîchissement automatique de la session (15min timer)...\&quot;, \&quot;SessionRefresh\&quot;)\n                        refreshSession()\n                    }\n                } catch (e: Exception) {\n                    MotiumApplication.logger.w(\&quot;⚠️ Erreur lors du rafraîchissement automatique: ${e.message}\&quot;, \&quot;SessionRefresh\&quot;)\n                    // Tentative de reconnexion avec retry\n                    attemptReconnection()\n                }\n            }\n        }\n    }\n\n    /**\n     * Tente de reconnecter en cas d\u0027échec de rafraîchissement\n     */\n    private suspend fun attemptReconnection() {\n        var retries \u003d 0\n        val maxRetries \u003d 3\n\n        while (retries \u003c maxRetries) {\n            delay((1 shl retries) * 2000L) // Délai exponentiel: 2s, 4s, 8s\n\n            try {\n                MotiumApplication.logger.i(\&quot; Tentative de reconnexion ${retries + 1}/$maxRetries\&quot;, \&quot;SessionRefresh\&quot;)\n                validateCurrentSession()\n                MotiumApplication.logger.i(\&quot;✅ Reconnexion réussie\&quot;, \&quot;SessionRefresh\&quot;)\n                break\n            } catch (e: Exception) {\n                retries++\n                MotiumApplication.logger.e(\&quot;❌ Reconnexion échouée (${retries}/$maxRetries): ${e.message}\&quot;, \&quot;SessionRefresh\&quot;, e)\n            }\n        }\n    }\n\n    /**\n     * Force le rafraîchissement de la session Supabase\n     * À appeler quand l\u0027app revient au premier plan ou périodiquement\n     */\n    suspend fun refreshSession() {\n        try {\n            val currentUser \u003d auth.currentUserOrNull()\n            if (currentUser !\u003d null) {\n                MotiumApplication.logger.i(\&quot; Rafraîchissement de session pour: ${currentUser.email}\&quot;, \&quot;SessionRefresh\&quot;)\n\n                // Vérifier si le token expire bientôt (5 minutes avant expiration)\n                if (secureSessionStorage.isTokenExpiringSoon(5)) {\n                    MotiumApplication.logger.w(\&quot;⚠️ Token expire bientôt - rafraîchissement prioritaire\&quot;, \&quot;SessionRefresh\&quot;)\n                }\n\n                // Forcer le rafraîchissement de la session\n                auth.refreshCurrentSession()\n\n                // Sauvegarder la nouvelle session de manière sécurisée\n                saveCurrentSessionSecurely()\n\n                MotiumApplication.logger.i(\&quot;✅ Session rafraîchie avec succès\&quot;, \&quot;SessionRefresh\&quot;)\n\n                // Mettre à jour l\u0027état d\u0027authentification\n                updateAuthState()\n            } else {\n                MotiumApplication.logger.w(\&quot;⚠️ Tentative de rafraîchissement sans utilisateur connecté\&quot;, \&quot;SessionRefresh\&quot;)\n            }\n        } catch (e: Exception) {\n            MotiumApplication.logger.e(\&quot;❌ Erreur lors du rafraîchissement de la session: ${e.message}\&quot;, \&quot;SessionRefresh\&quot;, e)\n\n            // Tenter une reconnexion au lieu de nettoyer immédiatement\n            try {\n                MotiumApplication.logger.i(\&quot; Tentative de reconnexion après échec de rafraîchissement\&quot;, \&quot;SessionRefresh\&quot;)\n                validateCurrentSession()\n            } catch (e2: Exception) {\n                // Si la reconnexion échoue aussi, alors nettoyer\n                MotiumApplication.logger.e(\&quot;❌ Reconnexion échouée, nettoyage de la session\&quot;, \&quot;SessionRefresh\&quot;, e2)\n                secureSessionStorage.clearSession()\n                _authState.value \u003d AuthState(\n                    isAuthenticated \u003d false,\n                    authUser \u003d null,\n                    user \u003d null,\n                    isLoading \u003d false,\n                    error \u003d \&quot;Session expirée - veuillez vous reconnecter\&quot;\n                )\n            }\n        }\n    }\n\n    /**\n     * Sauvegarde la session Supabase actuelle de manière sécurisée avec EncryptedSharedPreferences\n     */\n    private suspend fun saveCurrentSessionSecurely() {\n        try {\n            val currentSession \u003d auth.currentSessionOrNull()\n            val currentUser \u003d auth.currentUserOrNull()\n\n            if (currentSession !\u003d null \u0026\u0026 currentUser !\u003d null) {\n                // Calculer le timestamp d\u0027expiration (tokens Supabase expirent après 60 minutes)\n                val expiresInSeconds \u003d currentSession.expiresIn ?: 3600L // Default 1 heure\n                val expiresAt \u003d System.currentTimeMillis() + (expiresInSeconds * 1000L)\n\n                val sessionData \u003d SecureSessionStorage.SessionData(\n                    accessToken \u003d currentSession.accessToken,\n                    refreshToken \u003d currentSession.refreshToken ?: \&quot;\&quot;,\n                    expiresAt \u003d expiresAt,\n                    userId \u003d currentUser.id,\n                    userEmail \u003d currentUser.email ?: \&quot;\&quot;,\n                    tokenType \u003d currentSession.tokenType ?: \&quot;Bearer\&quot;,\n                    lastRefreshTime \u003d System.currentTimeMillis()\n                )\n\n                secureSessionStorage.saveSession(sessionData)\n                MotiumApplication.logger.i(\&quot;✅ Session sauvegardée de manière sécurisée (expire dans ${expiresInSeconds / 60} min)\&quot;, \&quot;SessionRefresh\&quot;)\n            } else {\n                MotiumApplication.logger.w(\&quot;⚠️ Impossible de sauvegarder la session - session ou utilisateur null\&quot;, \&quot;SessionRefresh\&quot;)\n            }\n        } catch (e: Exception) {\n            MotiumApplication.logger.e(\&quot;❌ Erreur lors de la sauvegarde sécurisée de la session: ${e.message}\&quot;, \&quot;SessionRefresh\&quot;, e)\n        }\n    }\n\n    /**\n     * Vérifie la validité de la session actuelle\n     * À appeler au démarrage de l\u0027app ou quand elle revient au premier plan\n     * Protégé par mutex pour éviter les validations concurrentes\n     */\n    suspend fun validateCurrentSession() \u003d sessionValidationMutex.withLock {\n        try {\n            MotiumApplication.logger.d(\&quot; Session validation - mutex acquired\&quot;, \&quot;SessionValidation\&quot;)\n            val currentUser \u003d auth.currentUserOrNull()\n\n            if (currentUser !\u003d null) {\n                // La session Supabase existe\n                MotiumApplication.logger.i(\&quot;Validation de session: utilisateur détecté ${currentUser.email}\&quot;, \&quot;SessionValidation\&quot;)\n\n                // Vérifier si le token expire bientôt ou est déjà expiré\n                val needsRefresh \u003d secureSessionStorage.isTokenExpired() || secureSessionStorage.isTokenExpiringSoon(5)\n\n                if (secureSessionStorage.isTokenExpired()) {\n                    MotiumApplication.logger.w(\&quot;⚠️ Token expiré - rafraîchissement urgent\&quot;, \&quot;SessionValidation\&quot;)\n                } else if (secureSessionStorage.isTokenExpiringSoon(5)) {\n                    MotiumApplication.logger.w(\&quot;⚠️ Token expire bientôt - rafraîchissement préventif\&quot;, \&quot;SessionValidation\&quot;)\n                } else {\n                    MotiumApplication.logger.i(\&quot;✅ Token encore valide - pas de refresh nécessaire\&quot;, \&quot;SessionValidation\&quot;)\n                }\n\n                // Ne rafraîchir QUE si le token est expiré ou expire bientôt\n                if (needsRefresh) {\n                    try {\n                        auth.refreshCurrentSession()\n                        saveCurrentSessionSecurely()\n                        updateAuthState()\n                        MotiumApplication.logger.i(\&quot;Session validée et rafraîchie avec succès\&quot;, \&quot;SessionValidation\&quot;)\n                } catch (e: Exception) {\n                    MotiumApplication.logger.e(\&quot;Impossible de rafraîchir la session: ${e.message}\&quot;, \&quot;SessionValidation\&quot;, e)\n\n                    // Distinguer les vraies erreurs d\u0027authentification des erreurs réseau temporaires\n                    val isAuthError \u003d e.message?.contains(\&quot;refresh_token\&quot;, ignoreCase \u003d true) \u003d\u003d true ||\n                                     e.message?.contains(\&quot;invalid\&quot;, ignoreCase \u003d true) \u003d\u003d true ||\n                                     e.message?.contains(\&quot;expired\&quot;, ignoreCase \u003d true) \u003d\u003d true ||\n                                     e.message?.contains(\&quot;401\&quot;, ignoreCase \u003d true) \u003d\u003d true ||\n                                     e.message?.contains(\&quot;unauthorized\&quot;, ignoreCase \u003d true) \u003d\u003d true\n\n                    if (isAuthError) {\n                        // Vraie erreur d\u0027authentification - déconnecter l\u0027utilisateur\n                        MotiumApplication.logger.e(\&quot;❌ Erreur d\u0027authentification détectée - déconnexion\&quot;, \&quot;SessionValidation\&quot;)\n                        secureSessionStorage.clearSession()\n                        _authState.value \u003d AuthState(\n                            isAuthenticated \u003d false,\n                            authUser \u003d null,\n                            user \u003d null,\n                            isLoading \u003d false,\n                            error \u003d \&quot;Session expirée - veuillez vous reconnecter\&quot;\n                        )\n                    } else {\n                        // Erreur réseau temporaire - garder la session\n                        MotiumApplication.logger.w(\&quot;⚠️ Erreur temporaire lors du refresh (probablement réseau) - session conservée\&quot;, \&quot;SessionValidation\&quot;)\n                        // Ne pas changer authState, garder l\u0027utilisateur connecté\n                        // Le refresh sera retenté lors de la prochaine validation\n                    }\n                    }\n                }\n            } else {\n                // Pas de session Supabase active\n                // Ne pas nettoyer immédiatement - vérifier si c\u0027est vraiment une déconnexion ou juste un problème temporaire\n                MotiumApplication.logger.i(\&quot;Validation de session: aucun utilisateur connecté\&quot;, \&quot;SessionValidation\&quot;)\n\n                // Ne nettoyer la session locale que si elle n\u0027est plus valide depuis longtemps\n                // Cela évite de nettoyer pendant les rafraîchissements temporaires\n                if (!secureSessionStorage.hasValidSession()) {\n                    MotiumApplication.logger.i(\&quot;Session locale également invalide - nettoyage complet\&quot;, \&quot;SessionValidation\&quot;)\n                    secureSessionStorage.clearSession()\n                } else {\n                    MotiumApplication.logger.w(\&quot;Session Supabase null mais session locale valide - conservation de la session locale\&quot;, \&quot;SessionValidation\&quot;)\n                }\n\n                _authState.value \u003d AuthState(\n                    isAuthenticated \u003d false,\n                    authUser \u003d null,\n                    user \u003d null,\n                    isLoading \u003d false,\n                    error \u003d null\n                )\n            }\n        } catch (e: Exception) {\n            MotiumApplication.logger.e(\&quot;Erreur lors de la validation de session: ${e.message}\&quot;, \&quot;SessionValidation\&quot;, e)\n            secureSessionStorage.clearSession()\n            _authState.value \u003d AuthState(\n                isAuthenticated \u003d false,\n                authUser \u003d null,\n                user \u003d null,\n                isLoading \u003d false,\n                error \u003d null\n            )\n        }\n    }\n\n    private suspend fun initializeAuthSession() \u003d sessionValidationMutex.withLock {\n        try {\n            MotiumApplication.logger.d(\&quot; Session initialization - mutex acquired\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n\n            // Vérifier d\u0027abord si on a une session sécurisée sauvegardée\n            val savedSession \u003d secureSessionStorage.restoreSession()\n\n            if (savedSession !\u003d null) {\n                MotiumApplication.logger.i(\&quot; Session sécurisée trouvée pour: ${savedSession.userEmail}\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n\n                try {\n                    // Vérifier si le token est déjà expiré\n                    val isExpired \u003d secureSessionStorage.isTokenExpired()\n\n                    if (isExpired) {\n                        // Token expiré: utiliser le refresh token pour obtenir une nouvelle session\n                        MotiumApplication.logger.w(\&quot;⚠️ Token expiré - rafraîchissement avec refresh token\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n\n                        // Utiliser directement le refresh token pour obtenir une nouvelle session\n                        val newSession \u003d auth.refreshSession(refreshToken \u003d savedSession.refreshToken)\n\n                        // Sauvegarder la nouvelle session\n                        saveCurrentSessionSecurely()\n\n                        MotiumApplication.logger.i(\&quot;✅ Session rafraîchie avec succès depuis token expiré\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n                    } else {\n                        // Token encore valide: importer la session dans le SDK\n                        val expiresInSeconds \u003d ((savedSession.expiresAt - System.currentTimeMillis()) / 1000).toLong()\n\n                        MotiumApplication.logger.i(\&quot; Importing session into Supabase SDK (expiresIn: ${expiresInSeconds}s)\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n\n                        // Créer un UserSession pour l\u0027import\n                        val userSession \u003d io.github.jan.supabase.auth.user.UserSession(\n                            accessToken \u003d savedSession.accessToken,\n                            refreshToken \u003d savedSession.refreshToken,\n                            expiresIn \u003d expiresInSeconds,\n                            tokenType \u003d savedSession.tokenType,\n                            user \u003d null\n                        )\n\n                        // Importer la session dans le SDK\n                        auth.importSession(userSession)\n                        MotiumApplication.logger.i(\&quot;✅ Session imported successfully into Supabase SDK\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n\n                        // Si le token expire bientôt (\u003c 5 minutes), rafraîchir préventivement\n                        if (expiresInSeconds \u003c 300) {\n                            MotiumApplication.logger.i(\&quot; Token expire bientôt - rafraîchissement préventif\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n                            auth.refreshCurrentSession()\n                            saveCurrentSessionSecurely()\n                        }\n                    }\n\n                    updateAuthState()\n                    MotiumApplication.logger.i(\&quot;✅ Session restored successfully\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n                    return@withLock\n\n                } catch (e: Exception) {\n                    MotiumApplication.logger.e(\&quot;❌ Erreur lors de la restauration de session: ${e.message}\&quot;, \&quot;SupabaseAuthRepository\&quot;, e)\n                    // En cas d\u0027échec, nettoyer et laisser l\u0027utilisateur se reconnecter\n                    secureSessionStorage.clearSession()\n                }\n            }\n\n            // Supabase charge automatiquement la session depuis le stockage\n            val currentUser \u003d auth.currentUserOrNull()\n\n            if (currentUser !\u003d null) {\n                // Session Supabase valide détectée\n                MotiumApplication.logger.i(\&quot;Session Supabase valide trouvée pour: ${currentUser.email}\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n\n                // Sauvegarder la session de manière sécurisée\n                saveCurrentSessionSecurely()\n\n                // L\u0027utilisateur est connecté\n                updateAuthState()\n            } else {\n                // Pas de session Supabase\n                MotiumApplication.logger.i(\&quot;Aucune session Supabase trouvée\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n\n                // En mode développement, tenter la connexion automatique (SI ACTIVÉE)\n                if (isDevelopmentMode() \u0026\u0026 AUTO_LOGIN_ENABLED) {\n                    MotiumApplication.logger.i(\&quot;Mode développement détecté - tentative de connexion automatique\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n                    tryDevelopmentAutoLogin()\n                } else {\n                    if (isDevelopmentMode() \u0026\u0026 !AUTO_LOGIN_ENABLED) {\n                        MotiumApplication.logger.w(\&quot;Auto-login désactivé - utiliser la connexion manuelle\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n                    }\n                    secureSessionStorage.clearSession()\n                    _authState.value \u003d AuthState(\n                        isAuthenticated \u003d false,\n                        authUser \u003d null,\n                        user \u003d null,\n                        isLoading \u003d false,\n                        error \u003d null\n                    )\n                }\n            }\n        } catch (e: Exception) {\n            MotiumApplication.logger.w(\&quot;Erreur lors de l\u0027initialisation de la session: ${e.message}\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n\n            // En mode développement, tenter la connexion automatique même en cas d\u0027erreur (SI ACTIVÉE)\n            if (isDevelopmentMode() \u0026\u0026 AUTO_LOGIN_ENABLED) {\n                MotiumApplication.logger.i(\&quot;Mode développement - tentative de connexion automatique après erreur\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n                tryDevelopmentAutoLogin()\n            } else {\n                // En cas d\u0027erreur, nettoyer toutes les sessions\n                secureSessionStorage.clearSession()\n                _authState.value \u003d AuthState(\n                    isAuthenticated \u003d false,\n                    authUser \u003d null,\n                    user \u003d null,\n                    isLoading \u003d false,\n                    error \u003d null\n                )\n            }\n        }\n    }\n\n    /**\n     * Tentative de connexion automatique en mode développement\n     * Permet de maintenir la connexion même après réinstallation de l\u0027app\n     */\n    private suspend fun tryDevelopmentAutoLogin() {\n        try {\n            MotiumApplication.logger.i(\&quot; Tentative de connexion automatique de développement avec: $DEV_EMAIL\&quot;, \&quot;DevAutoLogin\&quot;)\n\n            val result \u003d auth.signInWith(Email) {\n                email \u003d DEV_EMAIL\n                password \u003d DEV_PASSWORD\n            }\n\n            val authUser \u003d auth.currentUserOrNull()\n            if (authUser !\u003d null) {\n                MotiumApplication.logger.i(\&quot;✅ Connexion automatique de développement réussie! Utilisateur: ${authUser.email}\&quot;, \&quot;DevAutoLogin\&quot;)\n\n                // Sauvegarder la session de manière sécurisée\n                saveCurrentSessionSecurely()\n\n                // Mettre à jour l\u0027état d\u0027authentification\n                updateAuthState()\n            } else {\n                MotiumApplication.logger.w(\&quot;❌ Connexion automatique échouée - utilisateur null\&quot;, \&quot;DevAutoLogin\&quot;)\n                _authState.value \u003d AuthState(\n                    isAuthenticated \u003d false,\n                    authUser \u003d null,\n                    user \u003d null,\n                    isLoading \u003d false,\n                    error \u003d \&quot;Connexion automatique de développement échouée\&quot;\n                )\n            }\n\n        } catch (e: Exception) {\n            MotiumApplication.logger.e(\&quot;❌ Erreur lors de la connexion automatique de développement: ${e.message}\&quot;, \&quot;DevAutoLogin\&quot;, e)\n            _authState.value \u003d AuthState(\n                isAuthenticated \u003d false,\n                authUser \u003d null,\n                user \u003d null,\n                isLoading \u003d false,\n                error \u003d \&quot;Erreur de connexion automatique: ${e.message}\&quot;\n            )\n        }\n    }\n\n    override suspend fun signUp(request: RegisterRequest): AuthResult\u003cAuthUser\u003e {\n        return try {\n            _authState.value \u003d _authState.value.copy(isLoading \u003d true, error \u003d null)\n\n            auth.signUpWith(Email) {\n                email \u003d request.email\n                password \u003d request.password\n                data \u003d buildJsonObject {\n                    put(\&quot;name\&quot;, request.name)\n                    put(\&quot;role\&quot;, request.role.name)\n                }\n            }\n\n            val authUser \u003d auth.currentUserOrNull()?.let { userInfo -\u003e\n                AuthUser(\n                    id \u003d userInfo.id,\n                    email \u003d userInfo.email,\n                    isEmailConfirmed \u003d userInfo.emailConfirmedAt !\u003d null,\n                    provider \u003d \&quot;email\&quot;\n                )\n            } ?: throw Exception(\&quot;Failed to get user info after signup\&quot;)\n\n            // Sauvegarder la session de manière sécurisée\n            saveCurrentSessionSecurely()\n\n            updateAuthState()\n            AuthResult.Success(authUser)\n        } catch (e: Exception) {\n            _authState.value \u003d _authState.value.copy(isLoading \u003d false, error \u003d e.message)\n            AuthResult.Error(e.message ?: \&quot;Signup failed\&quot;, e)\n        }\n    }\n\n    override suspend fun signIn(request: LoginRequest): AuthResult\u003cAuthUser\u003e {\n        return try {\n            _authState.value \u003d _authState.value.copy(isLoading \u003d true, error \u003d null)\n\n            auth.signInWith(Email) {\n                email \u003d request.email\n                password \u003d request.password\n            }\n\n            val authUser \u003d auth.currentUserOrNull()?.let { userInfo -\u003e\n                AuthUser(\n                    id \u003d userInfo.id,\n                    email \u003d userInfo.email,\n                    isEmailConfirmed \u003d userInfo.emailConfirmedAt !\u003d null,\n                    provider \u003d \&quot;email\&quot;\n                )\n            } ?: throw Exception(\&quot;Failed to get user info after signin\&quot;)\n\n            // Sauvegarder la session de manière sécurisée\n            saveCurrentSessionSecurely()\n\n            // Démarrer la synchronisation périodique en arrière-plan\n            SyncScheduler.scheduleSyncWork(context)\n\n            updateAuthState()\n            AuthResult.Success(authUser)\n        } catch (e: Exception) {\n            _authState.value \u003d _authState.value.copy(isLoading \u003d false, error \u003d e.message)\n            AuthResult.Error(e.message ?: \&quot;Login failed\&quot;, e)\n        }\n    }\n\n    override suspend fun signInWithGoogle(idToken: String): AuthResult\u003cAuthUser\u003e {\n        return try {\n            _authState.value \u003d _authState.value.copy(isLoading \u003d true, error \u003d null)\n\n            // TODO: Implement Google Sign-In with Supabase\n            // Currently disabled due to API compatibility issues\n            throw Exception(\&quot;Google Sign-In not yet implemented\&quot;)\n\n        } catch (e: Exception) {\n            _authState.value \u003d _authState.value.copy(isLoading \u003d false, error \u003d e.message)\n            AuthResult.Error(e.message ?: \&quot;Google sign-in failed\&quot;, e)\n        }\n    }\n\n    override suspend fun signOut(): AuthResult\u003cUnit\u003e {\n        return try {\n            auth.signOut()\n            // Effacer la session sécurisée\n            secureSessionStorage.clearSession()\n            // Annuler la synchronisation périodique en arrière-plan\n            SyncScheduler.cancelSyncWork(context)\n            updateAuthState()\n            AuthResult.Success(Unit)\n        } catch (e: Exception) {\n            AuthResult.Error(e.message ?: \&quot;Sign out failed\&quot;, e)\n        }\n    }\n\n    override suspend fun getCurrentAuthUser(): AuthUser? {\n        // Try to get user from Supabase session first\n        val supabaseUser \u003d auth.currentUserOrNull()?.let { userInfo -\u003e\n            AuthUser(\n                id \u003d userInfo.id,\n                email \u003d userInfo.email,\n                isEmailConfirmed \u003d userInfo.emailConfirmedAt !\u003d null,\n                provider \u003d userInfo.appMetadata?.get(\&quot;provider\&quot;)?.toString()\n            )\n        }\n\n        // If no Supabase session, fallback to secure session data\n        return if (supabaseUser !\u003d null) {\n            supabaseUser\n        } else if (secureSessionStorage.hasValidSession()) {\n            val userId \u003d secureSessionStorage.getUserId()\n            val userEmail \u003d secureSessionStorage.getUserEmail()\n\n            if (userId !\u003d null \u0026\u0026 userEmail !\u003d null) {\n                MotiumApplication.logger.d(\n                    \&quot;No Supabase session but valid secure session - returning user from secure data\&quot;,\n                    \&quot;SupabaseAuthRepository\&quot;\n                )\n                AuthUser(\n                    id \u003d userId,\n                    email \u003d userEmail,\n                    isEmailConfirmed \u003d true, // Assume confirmed since they logged in previously\n                    provider \u003d \&quot;email\&quot;\n                )\n            } else {\n                MotiumApplication.logger.w(\n                    \&quot;Valid secure session but missing user data (id or email)\&quot;,\n                    \&quot;SupabaseAuthRepository\&quot;\n                )\n                null\n            }\n        } else {\n            null\n        }\n    }\n\n    override suspend fun isUserAuthenticated(): Boolean {\n        // Vérifier d\u0027abord la session Supabase\n        val hasSupabaseSession \u003d auth.currentUserOrNull() !\u003d null\n\n        // Si pas de session Supabase, vérifier la session sécurisée comme fallback\n        // Cela évite de considérer l\u0027utilisateur comme déconnecté pendant les rafraîchissements temporaires\n        return if (hasSupabaseSession) {\n            true\n        } else {\n            // Fallback: si session sécurisée valide, l\u0027importer dans le SDK\n            val hasSecureSession \u003d secureSessionStorage.hasValidSession()\n            if (hasSecureSession) {\n                MotiumApplication.logger.d(\&quot;No Supabase session but valid secure session - importing into SDK\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n\n                try {\n                    // Récupérer la session sécurisée\n                    val savedSession \u003d secureSessionStorage.restoreSession()\n\n                    if (savedSession !\u003d null) {\n                        // Vérifier si le token est déjà expiré\n                        val isExpired \u003d secureSessionStorage.isTokenExpired()\n\n                        if (isExpired) {\n                            // Token expiré: utiliser le refresh token pour obtenir une nouvelle session\n                            MotiumApplication.logger.w(\&quot;⚠️ Token expiré - rafraîchissement avec refresh token\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n\n                            val newSession \u003d auth.refreshSession(refreshToken \u003d savedSession.refreshToken)\n                            saveCurrentSessionSecurely()\n\n                            MotiumApplication.logger.i(\&quot;✅ Session rafraîchie avec succès depuis token expiré\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n                        } else {\n                            // Token encore valide: importer la session dans le SDK\n                            val expiresInSeconds \u003d ((savedSession.expiresAt - System.currentTimeMillis()) / 1000).toLong()\n\n                            MotiumApplication.logger.i(\&quot; Importing session into Supabase SDK (expiresIn: ${expiresInSeconds}s)\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n\n                            // Créer un UserSession pour l\u0027import\n                            val userSession \u003d io.github.jan.supabase.auth.user.UserSession(\n                                accessToken \u003d savedSession.accessToken,\n                                refreshToken \u003d savedSession.refreshToken,\n                                expiresIn \u003d expiresInSeconds,\n                                tokenType \u003d savedSession.tokenType,\n                                user \u003d null\n                            )\n\n                            // Importer la session dans le SDK\n                            auth.importSession(userSession)\n                            MotiumApplication.logger.i(\&quot;✅ Session imported successfully into Supabase SDK\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n\n                            // Si le token expire bientôt (\u003c 5 minutes), rafraîchir préventivement\n                            if (expiresInSeconds \u003c 300) {\n                                MotiumApplication.logger.i(\&quot; Token expire bientôt - rafraîchissement préventif\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n                                auth.refreshCurrentSession()\n                                saveCurrentSessionSecurely()\n                            }\n                        }\n\n                        updateAuthState()\n                        true\n                    } else {\n                        // Pas de session sécurisée valide finalement\n                        false\n                    }\n                } catch (e: Exception) {\n                    MotiumApplication.logger.e(\&quot;❌ Erreur lors de l\u0027import de session: ${e.message}\&quot;, \&quot;SupabaseAuthRepository\&quot;, e)\n                    // En cas d\u0027échec, nettoyer et retourner false\n                    secureSessionStorage.clearSession()\n                    false\n                }\n            } else {\n                false\n            }\n        }\n    }\n\n    override suspend fun sendPasswordResetEmail(email: String): AuthResult\u003cUnit\u003e {\n        return try {\n            auth.resetPasswordForEmail(email)\n            AuthResult.Success(Unit)\n        } catch (e: Exception) {\n            AuthResult.Error(e.message ?: \&quot;Failed to send reset email\&quot;, e)\n        }\n    }\n\n    override suspend fun confirmEmail(token: String): AuthResult\u003cUnit\u003e {\n        return try {\n            // Note: API might have changed in v3.x\n            // This is a placeholder implementation\n            AuthResult.Success(Unit)\n        } catch (e: Exception) {\n            AuthResult.Error(e.message ?: \&quot;Email confirmation failed\&quot;, e)\n        }\n    }\n\n    override suspend fun createUserProfile(authUser: AuthUser, name: String, isEnterprise: Boolean, organizationName: String): AuthResult\u003cUser\u003e {\n        return try {\n            val now \u003d Instant.DISTANT_FUTURE.toString() // TODO: Fix datetime\n\n            // Generate organization ID if user is enterprise\n            val organizationId \u003d if (isEnterprise) {\n                java.util.UUID.randomUUID().toString()\n            } else {\n                null\n            }\n\n            val userProfile \u003d UserProfile(\n                id \u003d authUser.id,\n                name \u003d name,\n                email \u003d authUser.email ?: \&quot;\&quot;,\n                role \u003d if (isEnterprise) \&quot;ENTERPRISE\&quot; else \&quot;INDIVIDUAL\&quot;,\n                organization_id \u003d organizationId,\n                organization_name \u003d if (isEnterprise) organizationName else null,\n                created_at \u003d now,\n                updated_at \u003d now\n            )\n\n            postgres.from(\&quot;users\&quot;).insert(userProfile)\n\n            val user \u003d User(\n                id \u003d authUser.id,\n                name \u003d name,\n                email \u003d authUser.email ?: \&quot;\&quot;,\n                role \u003d if (isEnterprise) UserRole.ENTERPRISE else UserRole.INDIVIDUAL,\n                organizationId \u003d organizationId,\n                organizationName \u003d if (isEnterprise) organizationName else null,\n                subscription \u003d Subscription(SubscriptionType.FREE, null),\n                monthlyTripCount \u003d 0,\n                createdAt \u003d Instant.DISTANT_FUTURE, // TODO: Fix datetime\n                updatedAt \u003d Instant.DISTANT_FUTURE // TODO: Fix datetime\n            )\n\n            updateAuthState()\n            AuthResult.Success(user)\n        } catch (e: Exception) {\n            AuthResult.Error(e.message ?: \&quot;Failed to create user profile\&quot;, e)\n        }\n    }\n\n    override suspend fun getUserProfile(userId: String): AuthResult\u003cUser\u003e {\n        return try {\n            val allUsers \u003d postgres.from(\&quot;users\&quot;)\n                .select()\n                .decodeList\u003cUserProfile\u003e()\n\n            val matchingUser \u003d allUsers.firstOrNull { it.id \u003d\u003d userId }\n\n            if (matchingUser \u003d\u003d null) {\n                MotiumApplication.logger.e(\&quot;❌ No user found in public.users with ID: $userId\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n                return AuthResult.Error(\&quot;User profile not found in database. Expected ID: $userId\&quot;)\n            }\n\n            MotiumApplication.logger.d(\&quot;✅ User profile loaded: ${matchingUser.email}\&quot;, \&quot;SupabaseAuthRepository\&quot;)\n            val user \u003d matchingUser.toDomainUser()\n            AuthResult.Success(user)\n        } catch (e: Exception) {\n            MotiumApplication.logger.e(\&quot;❌ Error fetching user profile: ${e.message}\&quot;, \&quot;SupabaseAuthRepository\&quot;, e)\n            AuthResult.Error(e.message ?: \&quot;Failed to get user profile\&quot;, e)\n        }\n    }\n\n    override suspend fun updateUserProfile(user: User): AuthResult\u003cUser\u003e {\n        return try {\n            val userProfile \u003d user.toUserProfile()\n            postgres.from(\&quot;users\&quot;)\n                .update(userProfile) {\n                    filter {\n                        UserProfile::id eq user.id\n                    }\n                }\n\n            updateAuthState()\n            AuthResult.Success(user)\n        } catch (e: Exception) {\n            AuthResult.Error(e.message ?: \&quot;Failed to update user profile\&quot;, e)\n        }\n    }\n\n    /**\n     * Met à jour le compteur de trajets mensuels pour l\u0027utilisateur\n     */\n    suspend fun updateMonthlyTripCount(userId: String, newCount: Int): AuthResult\u003cUnit\u003e {\n        return try {\n            @Serializable\n            data class MonthlyTripCountUpdate(\n                val monthly_trip_count: Int\n            )\n\n            postgres.from(\&quot;users\&quot;)\n                .update(MonthlyTripCountUpdate(monthly_trip_count \u003d newCount)) {\n                    filter {\n                        UserProfile::id eq userId\n                    }\n                }\n\n            // Rafraîchir l\u0027état d\u0027authentification pour avoir les données à jour\n            updateAuthState()\n            AuthResult.Success(Unit)\n        } catch (e: Exception) {\n            MotiumApplication.logger.e(\&quot;Erreur lors de la mise à jour du compteur de trajets: ${e.message}\&quot;, \&quot;SupabaseAuthRepository\&quot;, e)\n            AuthResult.Error(e.message ?: \&quot;Failed to update monthly trip count\&quot;, e)\n        }\n    }\n\n    /**\n     * Récupère l\u0027utilisateur actuellement connecté avec son profil complet\n     * Retourne null si aucun utilisateur n\u0027est connecté\n     */\n    suspend fun getCurrentUser(): User? {\n        val authUser \u003d getCurrentAuthUser() ?: return null\n\n        return try {\n            val result \u003d getUserProfile(authUser.id)\n            if (result is AuthResult.Success) {\n                result.data\n            } else {\n                null\n            }\n        } catch (e: Exception) {\n            MotiumApplication.logger.e(\&quot;Erreur lors de la récupération de l\u0027utilisateur: ${e.message}\&quot;, \&quot;SupabaseAuthRepository\&quot;, e)\n            null\n        }\n    }\n\n    private suspend fun updateAuthState() {\n        val authUser \u003d getCurrentAuthUser()\n        val user \u003d authUser?.let {\n            try {\n                val result \u003d getUserProfile(it.id)\n                if (result is AuthResult.Success) result.data else null\n            } catch (e: Exception) {\n                null\n            }\n        }\n\n        _authState.value \u003d AuthState(\n            isAuthenticated \u003d authUser !\u003d null,\n            authUser \u003d authUser,\n            user \u003d user,\n            isLoading \u003d false,\n            error \u003d null\n        )\n    }\n\n    private fun UserProfile.toDomainUser(): User {\n        return User(\n            id \u003d id,\n            name \u003d name,\n            email \u003d email,\n            role \u003d UserRole.valueOf(role),\n            organizationId \u003d organization_id,\n            organizationName \u003d organization_name,\n            subscription \u003d Subscription(\n                type \u003d SubscriptionType.valueOf(subscription_type),\n                expiresAt \u003d subscription_expires_at?.let { kotlinx.datetime.Instant.parse(it) }\n            ),\n            monthlyTripCount \u003d monthly_trip_count,\n            createdAt \u003d kotlinx.datetime.Instant.parse(created_at),\n            updatedAt \u003d kotlinx.datetime.Instant.parse(updated_at)\n        )\n    }\n\n    private fun User.toUserProfile(): UserProfile {\n        return UserProfile(\n            id \u003d id,\n            name \u003d name,\n            email \u003d email,\n            role \u003d role.name,\n            organization_id \u003d organizationId,\n            organization_name \u003d organizationName,\n            subscription_type \u003d subscription.type.name,\n            subscription_expires_at \u003d subscription.expiresAt?.toString(),\n            monthly_trip_count \u003d monthlyTripCount,\n            created_at \u003d createdAt.toString(),\n            updated_at \u003d updatedAt.toString()\n        )\n    }\n}&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Examinons également le MainActivity et le SplashScreen pour comprendre le flux d\u0027authentification :&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01DhAAhSerQL1LLUjAi83hua&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;app/src/main/java/com/application/motium/presentation/MainActivity.kt\&quot;}&quot;}},{&quot;id&quot;:&quot;toolu_bdrk_016FqxoDM18nhk7TegGJ457z&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;app/src/main/java/com/application/motium/presentation/splash/SplashScreen.kt\&quot;}&quot;}},{&quot;id&quot;:&quot;toolu_bdrk_01GSkriTnC9xPRuFLpEaRaxK&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;app/src/main/java/com/application/motium/presentation/navigation/MotiumNavHost.kt\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01DhAAhSerQL1LLUjAi83hua&quot;,&quot;content&quot;:&quot;package com.application.motium.presentation\n\nimport android.os.Bundle\nimport android.widget.Toast\nimport androidx.activity.ComponentActivity\nimport androidx.activity.compose.setContent\nimport androidx.activity.enableEdgeToEdge\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.compose.foundation.layout.fillMaxSize\nimport androidx.compose.foundation.layout.padding\nimport androidx.compose.material3.MaterialTheme\nimport androidx.compose.material3.Scaffold\nimport androidx.compose.material3.Surface\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.tooling.preview.Preview\nimport androidx.navigation.compose.rememberNavController\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.lifecycle.lifecycleScope\nimport com.application.motium.MotiumApplication\nimport com.application.motium.data.supabase.SupabaseAuthRepository\nimport com.application.motium.presentation.auth.AuthViewModel\nimport com.application.motium.presentation.navigation.MotiumNavHost\nimport com.application.motium.presentation.theme.MotiumTheme\nimport com.application.motium.utils.GoogleSignInHelper\nimport com.application.motium.utils.PermissionManager\nimport com.application.motium.utils.ThemeManager\nimport com.application.motium.service.SupabaseConnectionService\nimport com.application.motium.service.DozeModeFix\nimport com.application.motium.data.TripRepository\nimport kotlinx.coroutines.launch\nclass MainActivity : ComponentActivity() {\n\n    private val googleSignInHelper \u003d GoogleSignInHelper(this)\n    private lateinit var authRepository: SupabaseAuthRepository\n\n    private val requestPermissionLauncher \u003d registerForActivityResult(\n        ActivityResultContracts.RequestMultiplePermissions()\n    ) { permissions -\u003e\n        val allGranted \u003d permissions.all { it.value }\n        if (allGranted) {\n            Toast.makeText(this, \&quot;Toutes les permissions ont été accordées\&quot;, Toast.LENGTH_SHORT).show()\n        } else {\n            Toast.makeText(this, \&quot;Certaines permissions sont nécessaires pour le fonctionnement de l\u0027application\&quot;, Toast.LENGTH_LONG).show()\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // Logger l\u0027ouverture de l\u0027activité principale\n        MotiumApplication.logger.i(\&quot;MainActivity started\&quot;, \&quot;MainActivity\&quot;)\n\n        // Initialize auth repository for session management (using singleton)\n        authRepository \u003d SupabaseAuthRepository.getInstance(this)\n\n        // Initialize Google Sign-In helper\n        googleSignInHelper.initialize(this)\n\n        // Vérifier et demander les permissions au démarrage\n        if (!PermissionManager.hasAllRequiredPermissions(this)) {\n            MotiumApplication.logger.i(\&quot;Requesting permissions\&quot;, \&quot;MainActivity\&quot;)\n            PermissionManager.requestAllPermissions(this)\n        } else {\n            MotiumApplication.logger.i(\&quot;All permissions already granted\&quot;, \&quot;MainActivity\&quot;)\n        }\n\n        setContent {\n            val themeManager \u003d ThemeManager.getInstance(this)\n            val isDarkMode by themeManager.isDarkMode.collectAsState()\n\n            MotiumTheme(darkTheme \u003d isDarkMode) {\n                Surface(\n                    modifier \u003d Modifier.fillMaxSize(),\n                    color \u003d MaterialTheme.colorScheme.background\n                ) {\n                    MotiumApp()\n                }\n            }\n        }\n    }\n\n    override fun onResume() {\n        super.onResume()\n\n        // Valider et rafraîchir la session quand l\u0027app revient au premier plan\n        lifecycleScope.launch {\n            try {\n                MotiumApplication.logger.i(\&quot; App resumed - validating session\&quot;, \&quot;MainActivity\&quot;)\n                authRepository.validateCurrentSession()\n\n                // Démarrer le service de connexion si l\u0027utilisateur est authentifié\n                if (authRepository.isUserAuthenticated()) {\n                    MotiumApplication.logger.i(\&quot; User authenticated - starting connection service\&quot;, \&quot;MainActivity\&quot;)\n                    SupabaseConnectionService.startService(this@MainActivity)\n\n                    // CRITICAL: Si l\u0027auto-tracking est activé, demander l\u0027exemption d\u0027optimisation de batterie\n                    val tripRepository \u003d TripRepository.getInstance(this@MainActivity)\n                    if (tripRepository.isAutoTrackingEnabled()) {\n                        if (!DozeModeFix.isIgnoringBatteryOptimizations(this@MainActivity)) {\n                            MotiumApplication.logger.i(\n                                \&quot;⚠️ Auto-tracking enabled but app not exempted from battery optimization - requesting exemption\&quot;,\n                                \&quot;MainActivity\&quot;\n                            )\n                            DozeModeFix.requestBatteryOptimizationExemption(this@MainActivity)\n                        } else {\n                            MotiumApplication.logger.i(\n                                \&quot;✅ App already exempted from battery optimization\&quot;,\n                                \&quot;MainActivity\&quot;\n                            )\n                        }\n                    }\n                }\n            } catch (e: Exception) {\n                MotiumApplication.logger.e(\&quot;❌ Erreur lors de la validation de session au resume: ${e.message}\&quot;, \&quot;MainActivity\&quot;, e)\n            }\n        }\n    }\n\n    override fun onPause() {\n        super.onPause()\n        // Ne pas arrêter le service quand l\u0027app passe en arrière-plan\n        // Il doit continuer à maintenir la connexion\n        MotiumApplication.logger.i(\&quot;⏸️ App paused - connection service continues\&quot;, \&quot;MainActivity\&quot;)\n    }\n\n    override fun onRequestPermissionsResult(\n        requestCode: Int,\n        permissions: Array\u003cout String\u003e,\n        grantResults: IntArray\n    ) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults)\n        PermissionManager.handlePermissionResult(\n            requestCode \u003d requestCode,\n            permissions \u003d permissions,\n            grantResults \u003d grantResults,\n            onPermissionGranted \u003d {\n                MotiumApplication.logger.i(\&quot;Permissions granted successfully\&quot;, \&quot;MainActivity\&quot;)\n                Toast.makeText(this, \&quot;Permissions accordées\&quot;, Toast.LENGTH_SHORT).show()\n            },\n            onPermissionDenied \u003d {\n                MotiumApplication.logger.w(\&quot;Some permissions were denied\&quot;, \&quot;MainActivity\&quot;)\n                Toast.makeText(this, \&quot;Permissions refusées - Fonctionnalités limitées\&quot;, Toast.LENGTH_LONG).show()\n            }\n        )\n    }\n}\n\n@Composable\nfun MotiumApp() {\n    val navController \u003d rememberNavController()\n    val context \u003d LocalContext.current\n    val authViewModel: AuthViewModel \u003d viewModel {\n        AuthViewModel(\n            context \u003d context,\n            googleSignInHelper \u003d GoogleSignInHelper(context)\n        )\n    }\n\n    MotiumNavHost(\n        navController \u003d navController,\n        modifier \u003d Modifier.fillMaxSize(),\n        authViewModel \u003d authViewModel\n    )\n}\n\n@Preview(showBackground \u003d true)\n@Composable\nfun MotiumAppPreview() {\n    MotiumTheme {\n        MotiumApp()\n    }\n}&quot;},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_016FqxoDM18nhk7TegGJ457z&quot;,&quot;content&quot;:&quot;package com.application.motium.presentation.splash\n\nimport androidx.compose.foundation.background\nimport androidx.compose.foundation.layout.*\nimport androidx.compose.material3.*\nimport androidx.compose.runtime.*\nimport androidx.compose.ui.Alignment\nimport androidx.compose.ui.Modifier\nimport androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.platform.LocalContext\nimport androidx.compose.ui.text.font.FontWeight\nimport androidx.compose.ui.unit.dp\nimport androidx.compose.ui.unit.sp\nimport com.application.motium.presentation.theme.*\nimport com.application.motium.utils.ThemeManager\n\n@Composable\nfun SplashScreen() {\n    val context \u003d LocalContext.current\n    val themeManager \u003d remember { ThemeManager.getInstance(context) }\n    val isDarkMode by themeManager.isDarkMode.collectAsState()\n\n    val backgroundColor \u003d if (isDarkMode) BackgroundDark else BackgroundLight\n    val textColor \u003d if (isDarkMode) TextDark else TextLight\n\n    Box(\n        modifier \u003d Modifier\n            .fillMaxSize()\n            .background(backgroundColor),\n        contentAlignment \u003d Alignment.Center\n    ) {\n        Column(\n            horizontalAlignment \u003d Alignment.CenterHorizontally,\n            verticalArrangement \u003d Arrangement.spacedBy(24.dp)\n        ) {\n            // Logo/App name\n            Text(\n                text \u003d \&quot;Motium\&quot;,\n                style \u003d MaterialTheme.typography.displayMedium.copy(\n                    fontWeight \u003d FontWeight.Bold\n                ),\n                color \u003d MotiumPrimary,\n                fontSize \u003d 48.sp\n            )\n\n            // Loading indicator\n            CircularProgressIndicator(\n                modifier \u003d Modifier.size(48.dp),\n                color \u003d MotiumPrimary,\n                strokeWidth \u003d 4.dp\n            )\n\n            // Loading text\n            Text(\n                text \u003d \&quot;Loading...\&quot;,\n                style \u003d MaterialTheme.typography.bodyMedium,\n                color \u003d textColor.copy(alpha \u003d 0.7f),\n                fontSize \u003d 14.sp\n            )\n        }\n    }\n}\n&quot;},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01GSkriTnC9xPRuFLpEaRaxK&quot;,&quot;content&quot;:&quot;package com.application.motium.presentation.navigation\n\nimport androidx.compose.runtime.Composable\nimport androidx.compose.runtime.LaunchedEffect\nimport androidx.compose.runtime.collectAsState\nimport androidx.compose.runtime.getValue\nimport androidx.compose.ui.Modifier\nimport androidx.lifecycle.viewmodel.compose.viewModel\nimport androidx.navigation.NavHostController\nimport androidx.navigation.NavType\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.composable\nimport androidx.navigation.navArgument\nimport com.application.motium.presentation.auth.AuthViewModel\nimport com.application.motium.presentation.auth.LoginScreen\nimport com.application.motium.presentation.auth.RegisterScreen\nimport com.application.motium.presentation.individual.home.NewHomeScreen\nimport com.application.motium.presentation.individual.calendar.CalendarScreen\nimport com.application.motium.presentation.individual.vehicles.VehiclesScreen\nimport com.application.motium.presentation.individual.export.ExportScreen\nimport com.application.motium.presentation.individual.settings.SettingsScreen\nimport com.application.motium.presentation.individual.tripdetails.TripDetailsScreen\nimport com.application.motium.presentation.individual.addtrip.AddTripScreen\nimport com.application.motium.presentation.individual.edittrip.EditTripScreen\nimport com.application.motium.presentation.debug.LogViewerScreen\nimport com.application.motium.presentation.splash.SplashScreen\nimport com.application.motium.presentation.enterprise.home.EnterpriseHomeScreen\nimport com.application.motium.presentation.enterprise.employees.EmployeesManagementScreen\nimport com.application.motium.presentation.enterprise.employees.EmployeeDetailsScreen\nimport com.application.motium.presentation.enterprise.schedule.EmployeeScheduleScreen\nimport com.application.motium.presentation.enterprise.export.EmployeeExportScreen\nimport com.application.motium.presentation.enterprise.facturation.EmployeeFacturationScreen\nimport androidx.compose.ui.platform.LocalContext\nimport com.application.motium.data.TripRepository\nimport com.application.motium.data.supabase.SupabaseExpenseRepository\nimport kotlinx.coroutines.CoroutineScope\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\n\n@Composable\nfun MotiumNavHost(\n    navController: NavHostController,\n    modifier: Modifier \u003d Modifier,\n    authViewModel: AuthViewModel\n) {\n    val authState by authViewModel.authState.collectAsState()\n\n    // Navigation automatique basée sur l\u0027état d\u0027authentification\n    LaunchedEffect(authState.isLoading, authState.isAuthenticated, authState.user?.organizationId) {\n        if (!authState.isLoading) {\n            // Chargement terminé, naviguer vers la destination appropriée\n            if (authState.isAuthenticated) {\n                // Déterminer si l\u0027utilisateur est une entreprise\n                val isEnterprise \u003d authState.user?.organizationId !\u003d null\n                val homeRoute \u003d if (isEnterprise) \&quot;enterprise_home\&quot; else \&quot;home\&quot;\n\n                // Si l\u0027utilisateur est connecté, aller à l\u0027accueil approprié\n                navController.navigate(homeRoute) {\n                    popUpTo(\&quot;splash\&quot;) { inclusive \u003d true }\n                    popUpTo(\&quot;login\&quot;) { inclusive \u003d true }\n                    popUpTo(\&quot;register\&quot;) { inclusive \u003d true }\n                    launchSingleTop \u003d true\n                }\n            } else {\n                // Si l\u0027utilisateur n\u0027est pas connecté, aller à la connexion\n                navController.navigate(\&quot;login\&quot;) {\n                    popUpTo(\&quot;splash\&quot;) { inclusive \u003d true }\n                    launchSingleTop \u003d true\n                }\n            }\n        }\n    }\n\n    NavHost(\n        navController \u003d navController,\n        startDestination \u003d \&quot;splash\&quot;,\n        modifier \u003d modifier\n    ) {\n        // Splash/Loading screen\n        composable(\&quot;splash\&quot;) {\n            SplashScreen()\n        }\n        // Authentication screens\n        composable(\&quot;login\&quot;) {\n            LoginScreen(\n                onNavigateToRegister \u003d { navController.navigate(\&quot;register\&quot;) },\n                onNavigateToHome \u003d {\n                    navController.navigate(\&quot;home\&quot;) {\n                        popUpTo(\&quot;login\&quot;) { inclusive \u003d true }\n                    }\n                },\n                onForgotPassword \u003d { /* TODO: Implement forgot password */ },\n                viewModel \u003d authViewModel\n            )\n        }\n\n        composable(\&quot;register\&quot;) {\n            RegisterScreen(\n                onNavigateToLogin \u003d { navController.navigate(\&quot;login\&quot;) },\n                onNavigateToHome \u003d {\n                    navController.navigate(\&quot;home\&quot;) {\n                        popUpTo(\&quot;register\&quot;) { inclusive \u003d true }\n                    }\n                },\n                viewModel \u003d authViewModel\n            )\n        }\n        composable(\&quot;home\&quot;) {\n            NewHomeScreen(\n                onNavigateToCalendar \u003d { navController.navigate(\&quot;calendar\&quot;) },\n                onNavigateToVehicles \u003d { navController.navigate(\&quot;vehicles\&quot;) },\n                onNavigateToExport \u003d { navController.navigate(\&quot;export\&quot;) },\n                onNavigateToSettings \u003d { navController.navigate(\&quot;settings\&quot;) },\n                onNavigateToTripDetails \u003d { tripId -\u003e\n                    navController.navigate(\&quot;trip_details/$tripId\&quot;)\n                },\n                onNavigateToAddTrip \u003d { navController.navigate(\&quot;add_trip\&quot;) },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\&quot;add_trip\&quot;) {\n            val context \u003d LocalContext.current\n            val tripRepository \u003d TripRepository.getInstance(context)\n            val expenseRepository \u003d SupabaseExpenseRepository.getInstance(context)\n\n            AddTripScreen(\n                onNavigateBack \u003d { navController.popBackStack() },\n                onTripSaved \u003d { trip, expenses -\u003e\n                    CoroutineScope(Dispatchers.IO).launch {\n                        // Save trip first\n                        tripRepository.saveTrip(trip)\n\n                        // Then save expenses if any\n                        if (expenses.isNotEmpty()) {\n                            expenseRepository.saveExpenses(expenses)\n                        }\n                    }\n                    navController.popBackStack()\n                }\n            )\n        }\n\n        composable(\n            route \u003d \&quot;trip_details/{tripId}\&quot;,\n            arguments \u003d listOf(navArgument(\&quot;tripId\&quot;) { type \u003d NavType.StringType })\n        ) { backStackEntry -\u003e\n            val tripId \u003d backStackEntry.arguments?.getString(\&quot;tripId\&quot;) ?: \&quot;\&quot;\n            TripDetailsScreen(\n                tripId \u003d tripId,\n                onNavigateBack \u003d { navController.popBackStack() },\n                onNavigateToEdit \u003d { tripId -\u003e\n                    navController.navigate(\&quot;edit_trip/$tripId\&quot;)\n                },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\n            route \u003d \&quot;edit_trip/{tripId}\&quot;,\n            arguments \u003d listOf(navArgument(\&quot;tripId\&quot;) { type \u003d NavType.StringType })\n        ) { backStackEntry -\u003e\n            val tripId \u003d backStackEntry.arguments?.getString(\&quot;tripId\&quot;) ?: \&quot;\&quot;\n            EditTripScreen(\n                tripId \u003d tripId,\n                onNavigateBack \u003d { navController.popBackStack() },\n                onTripUpdated \u003d {\n                    navController.popBackStack()\n                }\n            )\n        }\n\n        composable(\&quot;calendar\&quot;) {\n            CalendarScreen(\n                onNavigateBack \u003d { navController.popBackStack() },\n                onNavigateToHome \u003d { navController.navigate(\&quot;home\&quot;) },\n                onNavigateToVehicles \u003d { navController.navigate(\&quot;vehicles\&quot;) },\n                onNavigateToExport \u003d { navController.navigate(\&quot;export\&quot;) },\n                onNavigateToSettings \u003d { navController.navigate(\&quot;settings\&quot;) },\n                onNavigateToTripDetails \u003d { tripId -\u003e\n                    navController.navigate(\&quot;trip_details/$tripId\&quot;)\n                },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\&quot;vehicles\&quot;) {\n            VehiclesScreen(\n                onNavigateBack \u003d { navController.popBackStack() },\n                onNavigateToHome \u003d { navController.navigate(\&quot;home\&quot;) },\n                onNavigateToCalendar \u003d { navController.navigate(\&quot;calendar\&quot;) },\n                onNavigateToExport \u003d { navController.navigate(\&quot;export\&quot;) },\n                onNavigateToSettings \u003d { navController.navigate(\&quot;settings\&quot;) },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\&quot;export\&quot;) {\n            ExportScreen(\n                onNavigateBack \u003d { navController.popBackStack() },\n                onNavigateToHome \u003d { navController.navigate(\&quot;home\&quot;) },\n                onNavigateToCalendar \u003d { navController.navigate(\&quot;calendar\&quot;) },\n                onNavigateToVehicles \u003d { navController.navigate(\&quot;vehicles\&quot;) },\n                onNavigateToSettings \u003d { navController.navigate(\&quot;settings\&quot;) },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\&quot;settings\&quot;) {\n            SettingsScreen(\n                onNavigateBack \u003d { navController.popBackStack() },\n                onNavigateToHome \u003d { navController.navigate(\&quot;home\&quot;) },\n                onNavigateToCalendar \u003d { navController.navigate(\&quot;calendar\&quot;) },\n                onNavigateToVehicles \u003d { navController.navigate(\&quot;vehicles\&quot;) },\n                onNavigateToExport \u003d { navController.navigate(\&quot;export\&quot;) },\n                onNavigateToLogViewer \u003d { navController.navigate(\&quot;log_viewer\&quot;) },\n                onNavigateToLogin \u003d {\n                    navController.navigate(\&quot;login\&quot;) {\n                        popUpTo(0) { inclusive \u003d true }\n                    }\n                },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\&quot;log_viewer\&quot;) {\n            LogViewerScreen(\n                onNavigateBack \u003d { navController.popBackStack() }\n            )\n        }\n\n        // Enterprise/Professional interface screens\n        composable(\&quot;enterprise_home\&quot;) {\n            EnterpriseHomeScreen(\n                onNavigateToCalendar \u003d { navController.navigate(\&quot;enterprise_calendar\&quot;) },\n                onNavigateToEmployees \u003d { navController.navigate(\&quot;employees_management\&quot;) },\n                onNavigateToSchedule \u003d { navController.navigate(\&quot;employee_schedule\&quot;) },\n                onNavigateToVehicles \u003d { navController.navigate(\&quot;enterprise_vehicles\&quot;) },\n                onNavigateToExport \u003d { navController.navigate(\&quot;enterprise_export\&quot;) },\n                onNavigateToSettings \u003d { navController.navigate(\&quot;enterprise_settings\&quot;) },\n                onNavigateToEmployeeExport \u003d { navController.navigate(\&quot;employee_export\&quot;) },\n                onNavigateToFacturation \u003d { navController.navigate(\&quot;employee_facturation\&quot;) },\n                onNavigateToTripDetails \u003d { tripId -\u003e\n                    navController.navigate(\&quot;trip_details/$tripId\&quot;)\n                },\n                onNavigateToAddTrip \u003d { navController.navigate(\&quot;add_trip\&quot;) },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\&quot;employees_management\&quot;) {\n            EmployeesManagementScreen(\n                onNavigateToHome \u003d { navController.navigate(\&quot;enterprise_home\&quot;) },\n                onNavigateToCalendar \u003d { navController.navigate(\&quot;enterprise_calendar\&quot;) },\n                onNavigateToExport \u003d { navController.navigate(\&quot;enterprise_export\&quot;) },\n                onNavigateToSettings \u003d { navController.navigate(\&quot;enterprise_settings\&quot;) },\n                onNavigateToSchedule \u003d { navController.navigate(\&quot;employee_schedule\&quot;) },\n                onNavigateToVehicles \u003d { navController.navigate(\&quot;enterprise_vehicles\&quot;) },\n                onNavigateToEmployeeExport \u003d { navController.navigate(\&quot;employee_export\&quot;) },\n                onNavigateToFacturation \u003d { navController.navigate(\&quot;employee_facturation\&quot;) },\n                onNavigateToEmployeeDetails \u003d { employeeId -\u003e\n                    navController.navigate(\&quot;employee_details/$employeeId\&quot;)\n                },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\n            route \u003d \&quot;employee_details/{employeeId}\&quot;,\n            arguments \u003d listOf(navArgument(\&quot;employeeId\&quot;) { type \u003d NavType.StringType })\n        ) { backStackEntry -\u003e\n            val employeeId \u003d backStackEntry.arguments?.getString(\&quot;employeeId\&quot;) ?: \&quot;\&quot;\n            EmployeeDetailsScreen(\n                employeeId \u003d employeeId,\n                employeeName \u003d \&quot;Employee Details\&quot;,\n                onNavigateBack \u003d { navController.popBackStack() },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\&quot;employee_schedule\&quot;) {\n            EmployeeScheduleScreen(\n                onNavigateToHome \u003d { navController.navigate(\&quot;enterprise_home\&quot;) },\n                onNavigateToCalendar \u003d { navController.navigate(\&quot;enterprise_calendar\&quot;) },\n                onNavigateToExport \u003d { navController.navigate(\&quot;enterprise_export\&quot;) },\n                onNavigateToSettings \u003d { navController.navigate(\&quot;enterprise_settings\&quot;) },\n                onNavigateToEmployees \u003d { navController.navigate(\&quot;employees_management\&quot;) },\n                onNavigateToVehicles \u003d { navController.navigate(\&quot;enterprise_vehicles\&quot;) },\n                onNavigateToEmployeeExport \u003d { navController.navigate(\&quot;employee_export\&quot;) },\n                onNavigateToFacturation \u003d { navController.navigate(\&quot;employee_facturation\&quot;) },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\&quot;employee_export\&quot;) {\n            EmployeeExportScreen(\n                onNavigateToHome \u003d { navController.navigate(\&quot;enterprise_home\&quot;) },\n                onNavigateToCalendar \u003d { navController.navigate(\&quot;enterprise_calendar\&quot;) },\n                onNavigateToExport \u003d { navController.navigate(\&quot;enterprise_export\&quot;) },\n                onNavigateToSettings \u003d { navController.navigate(\&quot;enterprise_settings\&quot;) },\n                onNavigateToEmployees \u003d { navController.navigate(\&quot;employees_management\&quot;) },\n                onNavigateToSchedule \u003d { navController.navigate(\&quot;employee_schedule\&quot;) },\n                onNavigateToVehicles \u003d { navController.navigate(\&quot;enterprise_vehicles\&quot;) },\n                onNavigateToFacturation \u003d { navController.navigate(\&quot;employee_facturation\&quot;) },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\&quot;employee_facturation\&quot;) {\n            EmployeeFacturationScreen(\n                onNavigateToHome \u003d { navController.navigate(\&quot;enterprise_home\&quot;) },\n                onNavigateToCalendar \u003d { navController.navigate(\&quot;enterprise_calendar\&quot;) },\n                onNavigateToExport \u003d { navController.navigate(\&quot;enterprise_export\&quot;) },\n                onNavigateToSettings \u003d { navController.navigate(\&quot;enterprise_settings\&quot;) },\n                onNavigateToEmployees \u003d { navController.navigate(\&quot;employees_management\&quot;) },\n                onNavigateToSchedule \u003d { navController.navigate(\&quot;employee_schedule\&quot;) },\n                onNavigateToVehicles \u003d { navController.navigate(\&quot;enterprise_vehicles\&quot;) },\n                onNavigateToEmployeeExport \u003d { navController.navigate(\&quot;employee_export\&quot;) },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        // Placeholder routes for enterprise versions of existing screens\n        // These will reuse the individual screens for now\n        composable(\&quot;enterprise_calendar\&quot;) {\n            CalendarScreen(\n                onNavigateBack \u003d { navController.popBackStack() },\n                onNavigateToHome \u003d { navController.navigate(\&quot;enterprise_home\&quot;) },\n                onNavigateToVehicles \u003d { navController.navigate(\&quot;enterprise_vehicles\&quot;) },\n                onNavigateToExport \u003d { navController.navigate(\&quot;enterprise_export\&quot;) },\n                onNavigateToSettings \u003d { navController.navigate(\&quot;enterprise_settings\&quot;) },\n                onNavigateToTripDetails \u003d { tripId -\u003e\n                    navController.navigate(\&quot;trip_details/$tripId\&quot;)\n                },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\&quot;enterprise_vehicles\&quot;) {\n            VehiclesScreen(\n                onNavigateBack \u003d { navController.popBackStack() },\n                onNavigateToHome \u003d { navController.navigate(\&quot;enterprise_home\&quot;) },\n                onNavigateToCalendar \u003d { navController.navigate(\&quot;enterprise_calendar\&quot;) },\n                onNavigateToExport \u003d { navController.navigate(\&quot;enterprise_export\&quot;) },\n                onNavigateToSettings \u003d { navController.navigate(\&quot;enterprise_settings\&quot;) },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\&quot;enterprise_export\&quot;) {\n            ExportScreen(\n                onNavigateBack \u003d { navController.popBackStack() },\n                onNavigateToHome \u003d { navController.navigate(\&quot;enterprise_home\&quot;) },\n                onNavigateToCalendar \u003d { navController.navigate(\&quot;enterprise_calendar\&quot;) },\n                onNavigateToVehicles \u003d { navController.navigate(\&quot;enterprise_vehicles\&quot;) },\n                onNavigateToSettings \u003d { navController.navigate(\&quot;enterprise_settings\&quot;) },\n                authViewModel \u003d authViewModel\n            )\n        }\n\n        composable(\&quot;enterprise_settings\&quot;) {\n            SettingsScreen(\n                onNavigateBack \u003d { navController.popBackStack() },\n                onNavigateToHome \u003d { navController.navigate(\&quot;enterprise_home\&quot;) },\n                onNavigateToCalendar \u003d { navController.navigate(\&quot;enterprise_calendar\&quot;) },\n                onNavigateToVehicles \u003d { navController.navigate(\&quot;enterprise_vehicles\&quot;) },\n                onNavigateToExport \u003d { navController.navigate(\&quot;enterprise_export\&quot;) },\n                onNavigateToLogViewer \u003d { navController.navigate(\&quot;log_viewer\&quot;) },\n                onNavigateToLogin \u003d {\n                    navController.navigate(\&quot;login\&quot;) {\n                        popUpTo(0) { inclusive \u003d true }\n                    }\n                },\n                authViewModel \u003d authViewModel\n            )\n        }\n    }\n}&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Maintenant, examinons l\u0027AuthViewModel et les services de synchronisation :&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01UeTJj3qFfLim9ep1dRCrEv&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;app/src/main/java/com/application/motium/presentation/auth/AuthViewModel.kt\&quot;}&quot;}},{&quot;id&quot;:&quot;toolu_bdrk_01BSajAtswvqFiys3gR5K4ZB&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;read_file&quot;,&quot;arguments&quot;:&quot;{\&quot;target_file\&quot;: \&quot;app/src/main/java/com/application/motium/data/sync/SessionRefreshWorker.kt\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01UeTJj3qFfLim9ep1dRCrEv&quot;,&quot;content&quot;:&quot;package com.application.motium.presentation.auth\n\nimport android.content.Context\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.application.motium.MotiumApplication\nimport com.application.motium.data.supabase.SupabaseAuthRepository\nimport com.application.motium.domain.model.*\nimport com.application.motium.domain.repository.AuthRepository\nimport com.application.motium.service.SupabaseConnectionService\nimport com.application.motium.utils.GoogleSignInHelper\nimport kotlinx.coroutines.flow.*\nimport kotlinx.coroutines.launch\n\nclass AuthViewModel(\n    private val context: Context,\n    private val authRepository: AuthRepository \u003d SupabaseAuthRepository.getInstance(context),\n    private val googleSignInHelper: GoogleSignInHelper? \u003d null\n) : ViewModel() {\n\n    val authState: StateFlow\u003cAuthState\u003e \u003d authRepository.authState\n        .stateIn(\n            scope \u003d viewModelScope,\n            started \u003d SharingStarted.WhileSubscribed(5000),\n            initialValue \u003d AuthState()\n        )\n\n    private val _loginState \u003d MutableStateFlow(LoginUiState())\n    val loginState: StateFlow\u003cLoginUiState\u003e \u003d _loginState.asStateFlow()\n\n    private val _registerState \u003d MutableStateFlow(RegisterUiState())\n    val registerState: StateFlow\u003cRegisterUiState\u003e \u003d _registerState.asStateFlow()\n\n    fun signIn(email: String, password: String) {\n        viewModelScope.launch {\n            _loginState.value \u003d _loginState.value.copy(isLoading \u003d true, error \u003d null)\n\n            val result \u003d authRepository.signIn(LoginRequest(email, password))\n            when (result) {\n                is AuthResult.Success -\u003e {\n                    _loginState.value \u003d _loginState.value.copy(isLoading \u003d false, isSuccess \u003d true)\n\n                    // Démarrer le service de connexion permanente après connexion réussie\n                    MotiumApplication.logger.i(\&quot;✅ Login successful - starting connection service\&quot;, \&quot;AuthViewModel\&quot;)\n                    SupabaseConnectionService.startService(context)\n                }\n                is AuthResult.Error -\u003e {\n                    _loginState.value \u003d _loginState.value.copy(\n                        isLoading \u003d false,\n                        error \u003d result.message\n                    )\n                }\n                AuthResult.Loading -\u003e {\n                    _loginState.value \u003d _loginState.value.copy(isLoading \u003d true)\n                }\n            }\n        }\n    }\n\n    fun signUp(email: String, password: String, name: String, isProfessional: Boolean \u003d false, organizationName: String \u003d \&quot;\&quot;) {\n        viewModelScope.launch {\n            _registerState.value \u003d _registerState.value.copy(isLoading \u003d true, error \u003d null)\n\n            //  FIX: Utiliser le role ENTERPRISE si professionnel, sinon INDIVIDUAL\n            val userRole \u003d if (isProfessional) UserRole.ENTERPRISE else UserRole.INDIVIDUAL\n            val result \u003d authRepository.signUp(RegisterRequest(email, password, name, userRole))\n            when (result) {\n                is AuthResult.Success -\u003e {\n                    // Create user profile after successful signup\n                    val profileResult \u003d authRepository.createUserProfile(result.data, name, isProfessional, organizationName)\n                    when (profileResult) {\n                        is AuthResult.Success -\u003e {\n                            _registerState.value \u003d _registerState.value.copy(\n                                isLoading \u003d false,\n                                isSuccess \u003d true\n                            )\n\n                            // Démarrer le service de connexion permanente après inscription réussie\n                            MotiumApplication.logger.i(\&quot;✅ Registration successful - starting connection service\&quot;, \&quot;AuthViewModel\&quot;)\n                            SupabaseConnectionService.startService(context)\n                        }\n                        is AuthResult.Error -\u003e {\n                            _registerState.value \u003d _registerState.value.copy(\n                                isLoading \u003d false,\n                                error \u003d profileResult.message\n                            )\n                        }\n                        AuthResult.Loading -\u003e {\n                            _registerState.value \u003d _registerState.value.copy(isLoading \u003d true)\n                        }\n                    }\n                }\n                is AuthResult.Error -\u003e {\n                    _registerState.value \u003d _registerState.value.copy(\n                        isLoading \u003d false,\n                        error \u003d result.message\n                    )\n                }\n                AuthResult.Loading -\u003e {\n                    _registerState.value \u003d _registerState.value.copy(isLoading \u003d true)\n                }\n            }\n        }\n    }\n\n    fun signInWithGoogle(idToken: String) {\n        viewModelScope.launch {\n            _loginState.value \u003d _loginState.value.copy(isLoading \u003d true, error \u003d null)\n\n            val result \u003d authRepository.signInWithGoogle(idToken)\n            when (result) {\n                is AuthResult.Success -\u003e {\n                    _loginState.value \u003d _loginState.value.copy(isLoading \u003d false, isSuccess \u003d true)\n                }\n                is AuthResult.Error -\u003e {\n                    _loginState.value \u003d _loginState.value.copy(\n                        isLoading \u003d false,\n                        error \u003d result.message\n                    )\n                }\n                AuthResult.Loading -\u003e {\n                    _loginState.value \u003d _loginState.value.copy(isLoading \u003d true)\n                }\n            }\n        }\n    }\n\n    fun initiateGoogleSignIn() {\n        googleSignInHelper?.signIn { result -\u003e\n            result.fold(\n                onSuccess \u003d { idToken -\u003e\n                    signInWithGoogle(idToken)\n                },\n                onFailure \u003d { exception -\u003e\n                    _loginState.value \u003d _loginState.value.copy(\n                        isLoading \u003d false,\n                        error \u003d \&quot;Google Sign-In failed: ${exception.message}\&quot;\n                    )\n                }\n            )\n        } ?: run {\n            _loginState.value \u003d _loginState.value.copy(\n                isLoading \u003d false,\n                error \u003d \&quot;Google Sign-In not properly configured\&quot;\n            )\n        }\n    }\n\n    fun signOut() {\n        viewModelScope.launch {\n            // Arrêter le service de connexion permanente avant déconnexion\n            MotiumApplication.logger.i(\&quot; Stopping connection service before sign out\&quot;, \&quot;AuthViewModel\&quot;)\n            SupabaseConnectionService.stopService(context)\n\n            authRepository.signOut()\n        }\n    }\n\n    fun sendPasswordResetEmail(email: String) {\n        viewModelScope.launch {\n            authRepository.sendPasswordResetEmail(email)\n        }\n    }\n\n    fun clearLoginError() {\n        _loginState.value \u003d _loginState.value.copy(error \u003d null)\n    }\n\n    fun clearRegisterError() {\n        _registerState.value \u003d _registerState.value.copy(error \u003d null)\n    }\n\n    fun resetLoginState() {\n        _loginState.value \u003d LoginUiState()\n    }\n\n    fun resetRegisterState() {\n        _registerState.value \u003d RegisterUiState()\n    }\n}\n\ndata class LoginUiState(\n    val isLoading: Boolean \u003d false,\n    val isSuccess: Boolean \u003d false,\n    val error: String? \u003d null\n)\n\ndata class RegisterUiState(\n    val isLoading: Boolean \u003d false,\n    val isSuccess: Boolean \u003d false,\n    val error: String? \u003d null\n)&quot;},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;read_file&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01BSajAtswvqFiys3gR5K4ZB&quot;,&quot;content&quot;:&quot;package com.application.motium.data.sync\n\nimport android.content.Context\nimport androidx.work.CoroutineWorker\nimport androidx.work.WorkerParameters\nimport com.application.motium.MotiumApplication\nimport com.application.motium.data.preferences.SecureSessionStorage\nimport com.application.motium.data.supabase.SupabaseAuthRepository\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\n\n/**\n * Worker pour rafraîchir la session Supabase en arrière-plan\n * Exécuté périodiquement par WorkManager toutes les 15-30 minutes\n *\n * Garantit que la session reste valide même quand l\u0027app est fermée\n */\nclass SessionRefreshWorker(\n    appContext: Context,\n    workerParams: WorkerParameters\n) : CoroutineWorker(appContext, workerParams) {\n\n    private val authRepository by lazy { SupabaseAuthRepository.getInstance(applicationContext) }\n    private val secureSessionStorage by lazy { SecureSessionStorage(applicationContext) }\n\n    override suspend fun doWork(): Result \u003d withContext(Dispatchers.IO) {\n        try {\n            MotiumApplication.logger.i(\&quot; BackgroundSync: Démarrage du refresh de session en arrière-plan\&quot;, \&quot;SessionRefreshWorker\&quot;)\n\n            // Vérifier si on a une session valide\n            if (!secureSessionStorage.hasSession()) {\n                MotiumApplication.logger.i(\&quot;⏭️ BackgroundSync: Aucune session trouvée, worker ignoré\&quot;, \&quot;SessionRefreshWorker\&quot;)\n                return@withContext Result.success()\n            }\n\n            // Vérifier si le token est expiré ou expire bientôt\n            if (secureSessionStorage.isTokenExpired()) {\n                MotiumApplication.logger.w(\&quot;❌ BackgroundSync: Token expiré - tentative de rafraîchissement\&quot;, \&quot;SessionRefreshWorker\&quot;)\n            } else if (secureSessionStorage.isTokenExpiringSoon(10)) {\n                MotiumApplication.logger.w(\&quot;⚠️ BackgroundSync: Token expire bientôt - rafraîchissement préventif\&quot;, \&quot;SessionRefreshWorker\&quot;)\n            } else {\n                MotiumApplication.logger.i(\&quot;✅ BackgroundSync: Token encore valide, rafraîchissement non nécessaire\&quot;, \&quot;SessionRefreshWorker\&quot;)\n                return@withContext Result.success()\n            }\n\n            // Tenter le rafraîchissement de la session\n            try {\n                authRepository.refreshSession()\n\n                // Vérifier que le refresh a réussi\n                if (secureSessionStorage.hasValidSession()) {\n                    MotiumApplication.logger.i(\&quot;✅ BackgroundSync: Session rafraîchie avec succès en arrière-plan\&quot;, \&quot;SessionRefreshWorker\&quot;)\n                    Result.success()\n                } else {\n                    MotiumApplication.logger.e(\&quot;❌ BackgroundSync: Session invalide après refresh\&quot;, \&quot;SessionRefreshWorker\&quot;)\n                    Result.retry()\n                }\n            } catch (e: Exception) {\n                MotiumApplication.logger.e(\&quot;❌ BackgroundSync: Erreur lors du refresh de session: ${e.message}\&quot;, \&quot;SessionRefreshWorker\&quot;, e)\n\n                // Retry si c\u0027est une erreur réseau temporaire\n                if (e.message?.contains(\&quot;network\&quot;, ignoreCase \u003d true) \u003d\u003d true ||\n                    e.message?.contains(\&quot;timeout\&quot;, ignoreCase \u003d true) \u003d\u003d true) {\n                    MotiumApplication.logger.i(\&quot; BackgroundSync: Erreur réseau - retry planifié\&quot;, \&quot;SessionRefreshWorker\&quot;)\n                    Result.retry()\n                } else {\n                    // Échec permanent\n                    MotiumApplication.logger.e(\&quot;❌ BackgroundSync: Échec permanent du refresh\&quot;, \&quot;SessionRefreshWorker\&quot;)\n                    Result.failure()\n                }\n            }\n        } catch (e: Exception) {\n            MotiumApplication.logger.e(\&quot;❌ BackgroundSync: Erreur fatale dans SessionRefreshWorker: ${e.message}\&quot;, \&quot;SessionRefreshWorker\&quot;, e)\n            Result.failure()\n        }\n    }\n\n    companion object {\n        const val WORK_NAME \u003d \&quot;session_refresh_worker\&quot;\n    }\n}\n&quot;},{&quot;role&quot;:&quot;assistant&quot;,&quot;content&quot;:[{&quot;type&quot;:&quot;text&quot;,&quot;text&quot;:&quot;Examinons aussi le service de connexion :&quot;}],&quot;tool_calls&quot;:[{&quot;id&quot;:&quot;toolu_bdrk_01AgWxjdcrkNBPUAQP3eRFJ1&quot;,&quot;type&quot;:&quot;function&quot;,&quot;function&quot;:{&quot;name&quot;:&quot;grep_search&quot;,&quot;arguments&quot;:&quot;{\&quot;query\&quot;: \&quot;SupabaseConnectionService\&quot;, \&quot;include_pattern\&quot;: \&quot;*.kt\&quot;, \&quot;explanation\&quot;: \&quot;Rechercher le service de connexion Supabase pour comprendre sa structure.\&quot;}&quot;}}]},{&quot;role&quot;:&quot;tool&quot;,&quot;name&quot;:&quot;grep_search&quot;,&quot;tool_call_id&quot;:&quot;toolu_bdrk_01AgWxjdcrkNBPUAQP3eRFJ1&quot;,&quot;content&quot;:&quot;File: app/src/main/java/com/application/motium/data/supabase/SupabaseAuthRepository.kt\n\tLine 113: * Note: Double couche de sécurité avec SupabaseConnectionService (20min)\n\nFile: app/src/main/java/com/application/motium/presentation/auth/AuthViewModel.kt\n\tLine 10: import com.application.motium.service.SupabaseConnectionService\n\tLine 45: SupabaseConnectionService.startService(context)\n\tLine 80: SupabaseConnectionService.startService(context)\n\tLine 153: SupabaseConnectionService.stopService(context)&quot;}]},&quot;81938889-bad3-456c-9a24-44a114c6cadb&quot;:{&quot;id&quot;:&quot;81938889-bad3-456c-9a24-44a114c6cadb&quot;,&quot;name&quot;:&quot;New Chat&quot;,&quot;timestamp&quot;:1764070511003,&quot;messages&quot;:[]}}" />
  </component>
</project>